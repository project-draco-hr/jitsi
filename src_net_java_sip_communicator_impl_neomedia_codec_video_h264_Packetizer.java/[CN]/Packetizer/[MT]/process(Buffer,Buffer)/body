{
  if (nals.size() > 0) {
    byte[] nal=nals.remove(0);
    outBuffer.setData(nal);
    outBuffer.setLength(nal.length);
    outBuffer.setOffset(0);
    outBuffer.setTimeStamp(nalsTimeStamp);
    outBuffer.setSequenceNumber(sequenceNumber++);
    if (nals.size() > 0)     return (BUFFER_PROCESSED_OK | INPUT_BUFFER_NOT_CONSUMED);
 else {
      outBuffer.setFlags(outBuffer.getFlags() | Buffer.FLAG_RTP_MARKER);
      return BUFFER_PROCESSED_OK;
    }
  }
  if (isEOM(inBuffer)) {
    propagateEOM(outBuffer);
    reset();
    return BUFFER_PROCESSED_OK;
  }
  if (inBuffer.isDiscard()) {
    outBuffer.setDiscard(true);
    reset();
    return BUFFER_PROCESSED_OK;
  }
  Format inFormat=inBuffer.getFormat();
  if ((inFormat != inputFormat) && !inFormat.matches(inputFormat))   setInputFormat(inFormat);
  int inLength=inBuffer.getLength();
  if (inLength < 4) {
    outBuffer.setDiscard(true);
    reset();
    return BUFFER_PROCESSED_OK;
  }
  byte[] inData=(byte[])inBuffer.getData();
  int inOffset=inBuffer.getOffset();
  boolean nalsAdded=false;
  int endIndex=inOffset + inLength;
  int beginIndex=ff_avc_find_startcode(inData,inOffset,endIndex);
  if (beginIndex < endIndex) {
    beginIndex+=3;
    for (int nextBeginIndex; (beginIndex < endIndex) && ((nextBeginIndex=ff_avc_find_startcode(inData,beginIndex,endIndex)) <= endIndex); beginIndex=nextBeginIndex + 3) {
      int nalLength=nextBeginIndex - beginIndex;
      while ((nalLength > 0) && (inData[beginIndex + nalLength - 1] == 0))       nalLength--;
      if (nalLength > 0)       nalsAdded=packetizeNAL(inData,beginIndex,nalLength) || nalsAdded;
    }
  }
  nalsTimeStamp=inBuffer.getTimeStamp();
  return nalsAdded ? process(inBuffer,outBuffer) : OUTPUT_BUFFER_NOT_FILLED;
}
