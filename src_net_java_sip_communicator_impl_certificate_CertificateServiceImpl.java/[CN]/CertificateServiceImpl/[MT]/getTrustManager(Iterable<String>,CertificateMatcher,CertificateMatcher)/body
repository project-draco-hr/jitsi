{
  X509TrustManager defaultTm=null;
  TrustManagerFactory tmFactory=TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
  tmFactory.init((KeyStore)null);
  for (  TrustManager m : tmFactory.getTrustManagers()) {
    if (m instanceof X509TrustManager) {
      defaultTm=(X509TrustManager)m;
      break;
    }
  }
  if (defaultTm == null)   throw new GeneralSecurityException("No default X509 trust manager found");
  final X509TrustManager tm=defaultTm;
  return new X509TrustManager(){
    private boolean serverCheck;
    public X509Certificate[] getAcceptedIssuers(){
      return tm.getAcceptedIssuers();
    }
    public void checkServerTrusted(    X509Certificate[] chain,    String authType) throws CertificateException {
      serverCheck=true;
      checkCertTrusted(chain,authType);
    }
    public void checkClientTrusted(    X509Certificate[] chain,    String authType) throws CertificateException {
      serverCheck=false;
      checkCertTrusted(chain,authType);
    }
    private void checkCertTrusted(    X509Certificate[] chain,    String authType) throws CertificateException {
      String defaultAlwaysTrustMode=CertificateVerificationActivator.getResources().getSettingsString(CertificateService.PNAME_ALWAYS_TRUST);
      if (config.getBoolean(PNAME_ALWAYS_TRUST,Boolean.parseBoolean(defaultAlwaysTrustMode)))       return;
      try {
        try {
          chain=tryBuildChain(chain);
        }
 catch (        Exception e) {
        }
        if (serverCheck)         tm.checkServerTrusted(chain,authType);
 else         tm.checkClientTrusted(chain,authType);
        if (identitiesToTest == null || !identitiesToTest.iterator().hasNext())         return;
 else         if (serverCheck)         serverVerifier.verify(identitiesToTest,chain[0]);
 else         clientVerifier.verify(identitiesToTest,chain[0]);
      }
 catch (      CertificateException e) {
        String thumbprint=getThumbprint(chain[0],THUMBPRINT_HASH_ALGORITHM);
        String propName=null;
        String message=null;
        String storedCert=null;
        String appName=R.getSettingsString("service.gui.APPLICATION_NAME");
        if (identitiesToTest == null || !identitiesToTest.iterator().hasNext()) {
          propName=PNAME_CERT_TRUST_PREFIX + ".server." + thumbprint;
          message=R.getI18NString("service.gui." + "CERT_DIALOG_DESCRIPTION_TXT_NOHOST",new String[]{appName});
          storedCert=config.getString(propName);
          if (storedCert == null)           storedCert=sessionAllowedCertificates.get(propName);
        }
 else {
          for (          String identity : identitiesToTest) {
            if (serverCheck) {
              message=R.getI18NString("service.gui." + "CERT_DIALOG_DESCRIPTION_TXT",new String[]{appName,identitiesToTest.toString()});
              propName=PNAME_CERT_TRUST_PREFIX + ".param." + identity;
            }
 else {
              message=R.getI18NString("service.gui." + "CERT_DIALOG_PEER_DESCRIPTION_TXT",new String[]{appName,identitiesToTest.toString()});
              propName=PNAME_CERT_TRUST_PREFIX + ".param." + identity;
            }
            storedCert=config.getString(propName);
            if (storedCert == null)             storedCert=sessionAllowedCertificates.get(propName);
            if (storedCert != null)             break;
          }
        }
        if (!thumbprint.equals(storedCert)) {
switch (verify(chain,message)) {
case DO_NOT_TRUST:
            throw new CertificateException("The peer provided certificate with Subject <" + chain[0].getSubjectDN() + "> is not trusted");
case TRUST_ALWAYS:
          config.setProperty(propName,thumbprint);
        break;
case TRUST_THIS_SESSION_ONLY:
      sessionAllowedCertificates.put(propName,thumbprint);
    break;
}
}
}
}
private X509Certificate[] tryBuildChain(X509Certificate[] chain) throws IOException, URISyntaxException, CertificateException {
if (chain.length != 1) return chain;
if (chain[0].getIssuerDN().equals(chain[0].getSubjectDN())) return chain;
List<X509Certificate> newChain=new ArrayList<X509Certificate>(chain.length + 4);
for (X509Certificate cert : chain) {
newChain.add(cert);
}
CertificateFactory certFactory=CertificateFactory.getInstance("X.509");
X509Certificate current=chain[chain.length - 1];
boolean foundParent;
int chainLookupCount=0;
do {
foundParent=false;
byte[] aiaBytes=current.getExtensionValue(X509Extension.authorityInfoAccess.getId());
if (aiaBytes == null) break;
DEROctetString octs=(DEROctetString)ASN1Object.fromByteArray(aiaBytes);
ASN1InputStream as=new ASN1InputStream(octs.getOctets());
AuthorityInformationAccess aia=AuthorityInformationAccess.getInstance(as.readObject());
for (AccessDescription ad : aia.getAccessDescriptions()) {
if (!ad.getAccessMethod().equals(AccessDescription.id_ad_caIssuers)) continue;
GeneralName gn=ad.getAccessLocation();
if (!(gn.getTagNo() == GeneralName.uniformResourceIdentifier && gn.getName() instanceof DERIA5String)) continue;
URI uri=new URI(((DERIA5String)gn.getName()).getString());
if (!(uri.getScheme().equalsIgnoreCase("http") || uri.getScheme().equals("https"))) continue;
if (logger.isDebugEnabled()) logger.debug("Downloading parent certificate for <" + current.getSubjectDN() + "> from <"+ uri+ ">");
try {
  InputStream is=HttpUtils.openURLConnection(uri.toString()).getContent();
  X509Certificate cert=(X509Certificate)certFactory.generateCertificate(is);
  if (!cert.getIssuerDN().equals(cert.getSubjectDN())) {
    newChain.add(cert);
    foundParent=true;
    current=cert;
    break;
  }
 else   logger.debug("Parent is self-signed, ignoring");
}
 catch (Exception e) {
  logger.debug("Could not download from <" + uri + ">");
}
}
chainLookupCount++;
}
 while (foundParent && chainLookupCount < 10);
chain=newChain.toArray(chain);
return chain;
}
}
;
}
