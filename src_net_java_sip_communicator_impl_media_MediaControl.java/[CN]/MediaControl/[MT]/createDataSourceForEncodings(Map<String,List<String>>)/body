{
  if (sourceProcessor == null) {
    logger.error("Processor is null.");
    throw new MediaException("The source Processor has not been " + "initialized.",MediaException.INTERNAL_ERROR);
  }
  if (sourceProcessor.getState() < Processor.Configured) {
    if (!processorUtility.waitForState(sourceProcessor,Processor.Configured)) {
      logger.error("Couldn't configure sourceProcessor");
      throw new MediaException("Couldn't configure sourceProcessor",MediaException.INTERNAL_ERROR);
    }
  }
  TrackControl[] tracks=sourceProcessor.getTrackControls();
  if ((tracks == null) || (tracks.length < 1)) {
    logger.error("Couldn't find any tracks in sourceProcessor");
    throw new MediaException("Couldn't find any tracks in sourceProcessor",MediaException.INTERNAL_ERROR);
  }
  if (logger.isDebugEnabled() && (sourceProcessor.getState() > Processor.Configured))   if (logger.isDebugEnabled())   logger.debug("sourceProcessor is in state " + sourceProcessor.getState() + " which is > Processor.Configured"+ " and then TrackControl.setFormat(Format) may not work.");
  boolean atLeastOneTrack=false;
  for (int i=0; i < tracks.length; i++) {
    if (!tracks[i].isEnabled()) {
      tracks[i].setEnabled(false);
      continue;
    }
    Format[] supported=tracks[i].getSupportedFormats();
    if (supported.length == 0) {
      if (logger.isDebugEnabled())       logger.debug("No available encodings.");
      tracks[i].setEnabled(false);
      continue;
    }
    if (logger.isDebugEnabled()) {
      logger.debug("Available encodings are:");
      for (int j=0; j < supported.length; j++) {
        if (logger.isDebugEnabled())         logger.debug("track[" + i + "] format["+ j+ "]="+ supported[j].getEncoding());
      }
    }
    if (supported[0] instanceof VideoFormat) {
      int index=findFirstMatchingFormat(supported,encodingSets);
      if (index != -1) {
        Format chosenFormat=assertSize((VideoFormat)supported[index]);
        tracks[i].setFormat(chosenFormat);
        if (logger.isDebugEnabled())         logger.debug("Track " + i + " is set to transmit "+ "as: "+ chosenFormat);
        atLeastOneTrack=true;
      }
 else {
        tracks[i].setEnabled(false);
      }
    }
 else {
      if (FMJConditionals.FORCE_AUDIO_FORMAT != null) {
        tracks[i].setFormat(FMJConditionals.FORCE_AUDIO_FORMAT);
        atLeastOneTrack=true;
      }
 else {
        int index=findFirstMatchingFormat(supported,encodingSets);
        if (index != -1) {
          Format setFormat=tracks[i].setFormat(supported[index]);
          if (logger.isDebugEnabled()) {
            logger.debug("Track " + i + " is set to transmit as: "+ setFormat);
          }
          atLeastOneTrack=true;
        }
 else {
          tracks[i].setEnabled(false);
        }
      }
    }
  }
  if (!atLeastOneTrack) {
    logger.error("Couldn't set any of the tracks to a valid RTP format");
    throw new MediaException("Couldn't set any of the tracks to a valid RTP format",MediaException.INTERNAL_ERROR);
  }
  if (!processorUtility.waitForState(sourceProcessor,Controller.Realized)) {
    logger.error("Couldn't realize sourceProcessor");
    throw new MediaException("Couldn't realize sourceProcessor",MediaException.INTERNAL_ERROR);
  }
  setJpegQuality(sourceProcessor,1f);
  return sourceProcessor.getDataOutput();
}
