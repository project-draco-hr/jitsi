{
  Collection<PacketExtension> extensions=sessionInitIQ.getExtensions();
  List<GTalkCandidatePacketExtension> candidates=new ArrayList<GTalkCandidatePacketExtension>();
  for (  PacketExtension ext : extensions) {
    if (ext.getElementName().equalsIgnoreCase(GTalkCandidatePacketExtension.ELEMENT_NAME)) {
      GTalkCandidatePacketExtension cand=(GTalkCandidatePacketExtension)ext;
      candidates.add(cand);
    }
  }
  try {
    getMediaHandler().processCandidates(candidates);
  }
 catch (  OperationFailedException ofe) {
    logger.warn("Failed to process an incoming candidates",ofe);
    String reasonText="Error: " + ofe.getMessage();
    SessionIQ errResp=GTalkPacketFactory.createSessionTerminate(sessionInitIQ.getTo(),sessionInitIQ.getFrom(),sessionInitIQ.getID(),Reason.GENERAL_ERROR,reasonText);
    TransportManagerGTalkImpl transportManager=getMediaHandler().queryTransportManager();
    if (transportManager != null)     transportManager.close();
    setState(CallPeerState.FAILED,reasonText);
    getProtocolProvider().getConnection().sendPacket(errResp);
    return;
  }
  if (sessAcceptedWithNoCands != null) {
    if (isInitiator()) {
      try {
        answer();
      }
 catch (      OperationFailedException e) {
        logger.info("Failed to answer call (FreeSwitch hack)");
      }
    }
 else {
      final SessionIQ sess=sessAcceptedWithNoCands;
      sessAcceptedWithNoCands=null;
      new Thread(){
        @Override public void run(){
          processSessionAccept(sess);
        }
      }
.start();
    }
    sessAcceptedWithNoCands=null;
  }
}
