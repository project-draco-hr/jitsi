{
  float[] tab_hup_s=TabLd8k.tab_hup_s;
  int ptr_h;
  float[] tab_den0=new float[F_UP_PST - 1], tab_den1=new float[F_UP_PST - 1];
  int ptr_den0, ptr_den1;
  int ptr_sig_past, ptr_sig_past0;
  int ptr1;
  int i, n, ioff, i_max;
  float ener, num, numsq, den0, den1;
  float den_int, num_int;
  float den_max, num_max, numsq_max;
  int phi_max;
  int lambda, phi;
  float temp0, temp1;
  int ptr_y_up;
  ener=0.f;
  for (i=0; i < L_SUBFR; i++) {
    ener+=ptr_sig_in[ptr_sig_in_offset + i] * ptr_sig_in[ptr_sig_in_offset + i];
  }
  if (ener < 0.1f) {
    num_gltp.value=0.f;
    den_gltp.value=1.f;
    ltpdel.value=0;
    phase.value=0;
    return;
  }
  lambda=t0 - 1;
  ptr_sig_past=ptr_sig_in_offset - lambda;
  num_int=-1.0e30f;
  i_max=0;
  for (i=0; i < 3; i++) {
    num=0.f;
    for (n=0; n < L_SUBFR; n++) {
      num+=ptr_sig_in[ptr_sig_in_offset + n] * ptr_sig_in[ptr_sig_past + n];
    }
    if (num > num_int) {
      i_max=i;
      num_int=num;
    }
    ptr_sig_past--;
  }
  if (num_int <= 0.f) {
    num_gltp.value=0.f;
    den_gltp.value=1.f;
    ltpdel.value=0;
    phase.value=0;
    return;
  }
  lambda+=i_max;
  ptr_sig_past=ptr_sig_in_offset - lambda;
  den_int=0.f;
  for (n=0; n < L_SUBFR; n++) {
    den_int+=ptr_sig_in[ptr_sig_past + n] * ptr_sig_in[ptr_sig_past + n];
  }
  if (den_int < 0.1f) {
    num_gltp.value=0.f;
    den_gltp.value=1.f;
    ltpdel.value=0;
    phase.value=0;
    return;
  }
  ptr_y_up=0;
  den_max=den_int;
  ptr_den0=0;
  ptr_den1=0;
  ptr_h=0;
  ptr_sig_past0=ptr_sig_in_offset + LH_UP_S - 1 - lambda;
  for (phi=1; phi < F_UP_PST; phi++) {
    ptr_sig_past=ptr_sig_past0;
    for (n=0; n <= L_SUBFR; n++) {
      ptr1=ptr_sig_past++;
      temp0=0.f;
      for (i=0; i < LH2_S; i++) {
        temp0+=tab_hup_s[ptr_h + i] * ptr_sig_in[ptr1 - i];
      }
      y_up[ptr_y_up + n]=temp0;
    }
    temp0=0.f;
    for (n=1; n < L_SUBFR; n++) {
      temp0+=y_up[ptr_y_up + n] * y_up[ptr_y_up + n];
    }
    den0=temp0 + y_up[ptr_y_up + 0] * y_up[ptr_y_up + 0];
    tab_den0[ptr_den0]=den0;
    ptr_den0++;
    den1=temp0 + y_up[ptr_y_up + L_SUBFR] * y_up[ptr_y_up + L_SUBFR];
    tab_den1[ptr_den1]=den1;
    ptr_den1++;
    if (Math.abs(y_up[ptr_y_up + 0]) > Math.abs(y_up[ptr_y_up + L_SUBFR])) {
      if (den0 > den_max) {
        den_max=den0;
      }
    }
 else {
      if (den1 > den_max) {
        den_max=den1;
      }
    }
    ptr_y_up+=L_SUBFRP1;
    ptr_h+=LH2_S;
  }
  if (den_max < 0.1f) {
    num_gltp.value=0.f;
    den_gltp.value=1.f;
    ltpdel.value=0;
    phase.value=0;
    return;
  }
  num_max=num_int;
  den_max=den_int;
  numsq_max=num_max * num_max;
  phi_max=0;
  ioff=1;
  ptr_den0=0;
  ptr_den1=0;
  ptr_y_up=0;
  for (phi=1; phi < F_UP_PST; phi++) {
    num=0.f;
    for (n=0; n < L_SUBFR; n++) {
      num+=ptr_sig_in[n] * y_up[ptr_y_up + n];
    }
    if (num < 0.f)     num=0.f;
    numsq=num * num;
    den0=tab_den0[ptr_den0];
    ptr_den0++;
    temp0=numsq * den_max;
    temp1=numsq_max * den0;
    if (temp0 > temp1) {
      num_max=num;
      numsq_max=numsq;
      den_max=den0;
      ioff=0;
      phi_max=phi;
    }
    ptr_y_up++;
    num=0.f;
    for (n=0; n < L_SUBFR; n++) {
      num+=ptr_sig_in[n] * y_up[ptr_y_up + n];
    }
    if (num < 0.f)     num=0.f;
    numsq=num * num;
    den1=tab_den1[ptr_den1];
    ptr_den1++;
    temp0=numsq * den_max;
    temp1=numsq_max * den1;
    if (temp0 > temp1) {
      num_max=num;
      numsq_max=numsq;
      den_max=den1;
      ioff=1;
      phi_max=phi;
    }
    ptr_y_up+=L_SUBFR;
  }
  if ((num_max == 0.f) || (den_max <= 0.1f)) {
    num_gltp.value=0.f;
    den_gltp.value=1.f;
    ltpdel.value=0;
    phase.value=0;
    return;
  }
  temp1=den_max * ener * THRESCRIT;
  if (numsq_max >= temp1) {
    ltpdel.value=lambda + 1 - ioff;
    off_yup.value=ioff;
    phase.value=phi_max;
    num_gltp.value=num_max;
    den_gltp.value=den_max;
  }
 else {
    num_gltp.value=0.f;
    den_gltp.value=1.f;
    ltpdel.value=0;
    phase.value=0;
  }
}
