{
  this.sessionInitIQ=sessionInitIQ;
  this.isInitiator=true;
  List<ContentPacketExtension> offer=sessionInitIQ.getContentList();
  try {
    getMediaHandler().processOffer(offer);
    CoinPacketExtension coin=null;
    for (    PacketExtension ext : sessionInitIQ.getExtensions()) {
      if (ext.getElementName().equals(CoinPacketExtension.ELEMENT_NAME)) {
        coin=(CoinPacketExtension)ext;
        break;
      }
    }
    if (coin != null) {
      setConferenceFocus(Boolean.parseBoolean((String)coin.getAttribute("isfocus")));
    }
  }
 catch (  Exception ex) {
    logger.info("Failed to process an incoming session initiate",ex);
    String reasonText="Error: " + ex.getMessage();
    JingleIQ errResp=JinglePacketFactory.createSessionTerminate(sessionInitIQ.getTo(),sessionInitIQ.getFrom(),sessionInitIQ.getSID(),Reason.INCOMPATIBLE_PARAMETERS,reasonText);
    setState(CallPeerState.FAILED,reasonText);
    getProtocolProvider().getConnection().sendPacket(errResp);
    return;
  }
  if (this.getDiscoverInfo() == null) {
    String calleeURI=sessionInitIQ.getFrom();
    DiscoverInfo discoverInfo=null;
    try {
      discoverInfo=getCall().getProtocolProvider().getDiscoveryManager().discoverInfo(calleeURI);
      if (discoverInfo != null) {
        this.setDiscoverInfo(discoverInfo);
      }
    }
 catch (    XMPPException ex) {
      logger.warn("could not retrieve info for " + calleeURI,ex);
    }
  }
  if (logger.isTraceEnabled())   logger.trace("will send ringing response: ");
  getProtocolProvider().getConnection().sendPacket(JinglePacketFactory.createRinging(sessionInitIQ));
synchronized (sessionInitiateSyncRoot) {
    sessionInitiateProcessed=true;
    sessionInitiateSyncRoot.notify();
  }
}
