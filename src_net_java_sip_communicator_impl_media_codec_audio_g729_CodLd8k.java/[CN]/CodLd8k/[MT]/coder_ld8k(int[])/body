{
  float[] r=new float[MP1];
  float[] A_t=new float[(MP1) * 2];
  float[] Aq_t=new float[(MP1) * 2];
  float[] Ap1=new float[MP1];
  float[] Ap2=new float[MP1];
  float[] A, Aq;
  int A_offset, Aq_offset;
  float[] lsp_new=new float[M], lsp_new_q=new float[M];
  float[] lsf_int=new float[M];
  float[] lsf_new=new float[M];
  float[] rc=new float[M];
  float[] gamma1=new float[2];
  float[] gamma2=new float[2];
  float[] synth=new float[L_FRAME];
  float[] h1=new float[L_SUBFR];
  float[] xn=new float[L_SUBFR];
  float[] xn2=new float[L_SUBFR];
  float[] code=new float[L_SUBFR];
  float[] y1=new float[L_SUBFR];
  float[] y2=new float[L_SUBFR];
  float[] g_coeff=new float[5];
  int i, j, i_gamma, i_subfr;
  IntReference iRef=new IntReference();
  int T_op, t0;
  IntReference t0_min=new IntReference(), t0_max=new IntReference(), t0_frac=new IntReference();
  int index, taming;
  float gain_pit, gain_code=0.0f;
  FloatReference _gain_pit=new FloatReference(), _gain_code=new FloatReference();
  int ana_offset=0;
  Lpc.autocorr(p_window,p_window_offset,M,r);
  Lpc.lag_window(M,r);
  Lpc.levinson(r,A_t,MP1,rc);
  Lpc.az_lsp(A_t,MP1,lsp_new,lsp_old);
  quaLsp.qua_lsp(lsp_new,lsp_new_q,ana);
  ana_offset+=2;
  Lpcfunc.int_lpc(lsp_old,lsp_new,lsf_int,lsf_new,A_t);
  Lpcfunc.int_qlpc(lsp_old_q,lsp_new_q,Aq_t);
  for (i=0; i < M; i++) {
    lsp_old[i]=lsp_new[i];
    lsp_old_q[i]=lsp_new_q[i];
  }
  pwf.perc_var(gamma1,gamma2,lsf_int,lsf_new,rc);
  Lpcfunc.weight_az(A_t,0,gamma1[0],M,Ap1);
  Lpcfunc.weight_az(A_t,0,gamma2[0],M,Ap2);
  Filter.residu(Ap1,0,speech,speech_offset,wsp,wsp_offset,L_SUBFR);
  Filter.syn_filt(Ap2,0,wsp,wsp_offset,wsp,wsp_offset,L_SUBFR,mem_w,0,1);
  Lpcfunc.weight_az(A_t,MP1,gamma1[1],M,Ap1);
  Lpcfunc.weight_az(A_t,MP1,gamma2[1],M,Ap2);
  Filter.residu(Ap1,0,speech,speech_offset + L_SUBFR,wsp,wsp_offset + L_SUBFR,L_SUBFR);
  Filter.syn_filt(Ap2,0,wsp,wsp_offset + L_SUBFR,wsp,wsp_offset + L_SUBFR,L_SUBFR,mem_w,0,1);
  T_op=Pitch.pitch_ol(wsp,wsp_offset,PIT_MIN,PIT_MAX,L_FRAME);
  t0_min.value=T_op - 3;
  if (t0_min.value < PIT_MIN)   t0_min.value=PIT_MIN;
  t0_max.value=t0_min.value + 6;
  if (t0_max.value > PIT_MAX) {
    t0_max.value=PIT_MAX;
    t0_min.value=t0_max.value - 6;
  }
  A=A_t;
  A_offset=0;
  Aq=Aq_t;
  Aq_offset=0;
  i_gamma=0;
  for (i_subfr=0; i_subfr < L_FRAME; i_subfr+=L_SUBFR) {
    Lpcfunc.weight_az(A,A_offset,gamma1[i_gamma],M,Ap1);
    Lpcfunc.weight_az(A,A_offset,gamma2[i_gamma],M,Ap2);
    i_gamma++;
    for (i=0; i <= M; i++)     ai_zero[i]=Ap1[i];
    Filter.syn_filt(Aq,Aq_offset,ai_zero,0,h1,0,L_SUBFR,zero,zero_offset,0);
    Filter.syn_filt(Ap2,0,h1,0,h1,0,L_SUBFR,zero,zero_offset,0);
    Filter.residu(Aq,Aq_offset,speech,speech_offset + i_subfr,exc,exc_offset + i_subfr,L_SUBFR);
    Filter.syn_filt(Aq,Aq_offset,exc,exc_offset + i_subfr,error,error_offset,L_SUBFR,mem_err,0,0);
    Filter.residu(Ap1,0,error,error_offset,xn,0,L_SUBFR);
    Filter.syn_filt(Ap2,0,xn,0,xn,0,L_SUBFR,mem_w0,0,0);
    t0=Pitch.pitch_fr3(exc,exc_offset + i_subfr,xn,h1,L_SUBFR,t0_min.value,t0_max.value,i_subfr,t0_frac);
    index=Pitch.enc_lag3(t0,t0_frac.value,t0_min,t0_max,PIT_MIN,PIT_MAX,i_subfr);
    ana[ana_offset]=index;
    ana_offset++;
    if (i_subfr == 0) {
      ana[ana_offset]=PParity.parity_pitch(index);
      ana_offset++;
    }
    PredLt3.pred_lt_3(exc,exc_offset + i_subfr,t0,t0_frac.value,L_SUBFR);
    Filter.convolve(exc,exc_offset + i_subfr,h1,y1,L_SUBFR);
    gain_pit=Pitch.g_pitch(xn,y1,g_coeff,L_SUBFR);
    taming=this.taming.test_err(t0,t0_frac.value);
    if (taming == 1) {
      if (gain_pit > GPCLIP) {
        gain_pit=GPCLIP;
      }
    }
    for (i=0; i < L_SUBFR; i++)     xn2[i]=xn[i] - y1[i] * gain_pit;
    iRef.value=i;
    index=acelpCo.ACELP_codebook(xn2,h1,t0,sharp,i_subfr,code,y2,iRef);
    i=iRef.value;
    ana[ana_offset]=index;
    ana_offset++;
    ana[ana_offset]=i;
    ana_offset++;
    CorFunc.corr_xy2(xn,y1,y2,g_coeff);
    _gain_pit.value=gain_pit;
    _gain_code.value=gain_code;
    ana[ana_offset]=quaGain.qua_gain(code,g_coeff,L_SUBFR,_gain_pit,_gain_code,taming);
    gain_pit=_gain_pit.value;
    gain_code=_gain_code.value;
    ana_offset++;
    sharp=gain_pit;
    if (sharp > SHARPMAX)     sharp=SHARPMAX;
    if (sharp < SHARPMIN)     sharp=SHARPMIN;
    for (i=0; i < L_SUBFR; i++)     exc[exc_offset + i + i_subfr]=gain_pit * exc[exc_offset + i + i_subfr] + gain_code * code[i];
    this.taming.update_exc_err(gain_pit,t0);
    Filter.syn_filt(Aq,Aq_offset,exc,exc_offset + i_subfr,synth,i_subfr,L_SUBFR,mem_syn,0,1);
    for (i=L_SUBFR - M, j=0; i < L_SUBFR; i++, j++) {
      mem_err[j]=speech[speech_offset + i_subfr + i] - synth[i_subfr + i];
      mem_w0[j]=xn[i] - gain_pit * y1[i] - gain_code * y2[i];
    }
    A_offset+=MP1;
    Aq_offset+=MP1;
  }
  Util.copy(old_speech,L_FRAME,old_speech,L_TOTAL - L_FRAME);
  Util.copy(old_wsp,L_FRAME,old_wsp,PIT_MAX);
  Util.copy(old_exc,L_FRAME,old_exc,PIT_MAX + L_INTERPOL);
}
