{
  float ALPHA=Ld8k.ALPHA;
  float BETA=Ld8k.BETA;
  float GAMMA1_0=Ld8k.GAMMA1_0;
  float GAMMA1_1=Ld8k.GAMMA1_1;
  float GAMMA2_0_H=Ld8k.GAMMA2_0_H;
  float GAMMA2_0_L=Ld8k.GAMMA2_0_L;
  float GAMMA2_1=Ld8k.GAMMA2_1;
  int M=Ld8k.M;
  float THRESH_H1=Ld8k.THRESH_H1;
  float THRESH_H2=Ld8k.THRESH_H2;
  float THRESH_L1=Ld8k.THRESH_L1;
  float THRESH_L2=Ld8k.THRESH_L2;
  float[] lar=new float[4];
  float[] lsf;
  float critlar0, critlar1;
  float d_min, temp;
  int i, k;
  float[] lar_new=lar;
  int lar_new_offset=2;
  for (i=0; i < 2; i++)   lar_new[lar_new_offset + i]=(float)Math.log10((double)((1.0f + r_c[i]) / (1.0f - r_c[i])));
  for (i=0; i < 2; i++) {
    lar[i]=0.5f * (lar_new[lar_new_offset + i] + lar_old[i]);
    lar_old[i]=lar_new[lar_new_offset + i];
  }
  for (k=0; k < 2; k++) {
    critlar0=lar[2 * k];
    critlar1=lar[2 * k + 1];
    if (smooth != 0) {
      if ((critlar0 < THRESH_L1) && (critlar1 > THRESH_H1))       smooth=0;
    }
 else {
      if ((critlar0 > THRESH_L2) || (critlar1 < THRESH_H2))       smooth=1;
    }
    if (smooth == 0) {
      gamma1[k]=GAMMA1_0;
      if (k == 0)       lsf=lsfint;
 else       lsf=lsfnew;
      d_min=lsf[1] - lsf[0];
      for (i=1; i < M - 1; i++) {
        temp=lsf[i + 1] - lsf[i];
        if (temp < d_min)         d_min=temp;
      }
      gamma2[k]=ALPHA * d_min + BETA;
      if (gamma2[k] > GAMMA2_0_H)       gamma2[k]=GAMMA2_0_H;
      if (gamma2[k] < GAMMA2_0_L)       gamma2[k]=GAMMA2_0_L;
    }
 else {
      gamma1[k]=GAMMA1_1;
      gamma2[k]=GAMMA2_1;
      ;
    }
  }
}
