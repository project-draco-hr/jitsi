{
  JNIEncoder encoder=null;
  SwScaler scaler=null;
  int codecCount=0;
  if ("h264/rtp".equalsIgnoreCase(format.getEncoding())) {
    encoder=new JNIEncoder();
{
      Map<String,String> formatParameters=mediaFormat.getFormatParameters();
      String packetizationMode=(formatParameters == null) ? null : formatParameters.get(JNIEncoder.PACKETIZATION_MODE_FMTP);
      encoder.setPacketizationMode(packetizationMode);
    }
    if (usePLI) {
      try {
        ((ControlTransformInputStream)rtpConnector.getControlInputStream()).addRTCPFeedbackListener(encoder);
      }
 catch (      IOException ioe) {
        logger.error("Error cannot get RTCP input stream",ioe);
      }
    }
    if (keyFrameControl != null)     encoder.setKeyFrameControl(keyFrameControl);
    codecCount++;
  }
  if (outputSize != null) {
    scaler=new SwScaler();
    scaler.setOutputSize(outputSize);
    codecCount++;
  }
  Codec[] codecs=new Codec[codecCount];
  codecCount=0;
  if (scaler != null)   codecs[codecCount++]=scaler;
  if (encoder != null)   codecs[codecCount++]=encoder;
  if (codecCount != 0) {
    try {
      trackControl.setCodecChain(codecs);
    }
 catch (    UnsupportedPlugInException upiex) {
      logger.error("Failed to add SwScaler/JNIEncoder to codec chain",upiex);
    }
  }
  return super.setProcessorFormat(trackControl,mediaFormat,format);
}
