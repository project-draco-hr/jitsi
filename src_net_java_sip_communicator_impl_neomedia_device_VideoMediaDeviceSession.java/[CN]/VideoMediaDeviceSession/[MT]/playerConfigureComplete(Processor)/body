{
  super.playerConfigureComplete(player);
  TrackControl[] trackControls=player.getTrackControls();
  SwScaler playerScaler=null;
  if ((trackControls != null) && (trackControls.length != 0)) {
    try {
      for (      TrackControl trackControl : trackControls) {
        playerScaler=new SwScaler(){
          /** 
 * The last size reported in the form of a
 * SizeChangeEvent.
 */
          private Dimension lastSize;
          @Override public int process(          Buffer input,          Buffer output){
            int result=super.process(input,output);
            if (result == BUFFER_PROCESSED_OK) {
              Format inputFormat=input.getFormat();
              if (inputFormat != null) {
                Dimension inputSize=((VideoFormat)inputFormat).getSize();
                if ((inputSize != null) && ((lastSize == null) || !lastSize.equals(inputSize))) {
                  lastSize=inputSize;
                  playerSizeChange(player,lastSize.width,lastSize.height);
                }
              }
            }
            return result;
          }
        }
;
        if (format.getEncoding().equals("h264/rtp") && usePLI) {
          DePacketizer depack=new DePacketizer();
          depack.setRtcpFeedbackPLI(usePLI);
          try {
            depack.setConnector(rtpConnector.getControlOutputStream());
          }
 catch (          Exception e) {
            logger.error("Error cannot get RTCP output stream",e);
          }
          depack.setSSRC(localSSRC,remoteSSRC);
          trackControl.setCodecChain(new Codec[]{depack,playerScaler});
        }
 else {
          trackControl.setCodecChain(new Codec[]{playerScaler});
        }
        break;
      }
    }
 catch (    UnsupportedPlugInException upiex) {
      logger.error("Failed to add SwScaler to codec chain",upiex);
      playerScaler=null;
    }
  }
  this.playerScaler=playerScaler;
}
