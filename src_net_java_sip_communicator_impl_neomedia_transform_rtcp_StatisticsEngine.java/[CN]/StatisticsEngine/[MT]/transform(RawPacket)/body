{
  try {
    numberOfSenderReports++;
    byte[] data=pkt.getBuffer();
    int offset=pkt.getOffset();
    int length=pkt.getLength();
    RTCPHeader header=new RTCPHeader(data,offset,length);
    if (header.getPacketType() == RTCPPacket.SR) {
      RTCPSenderReport report=new RTCPSenderReport(data,offset,length);
      if (report.getFeedbackReports().size() > 0) {
        RTCPFeedback feedback=(RTCPFeedback)report.getFeedbackReports().get(0);
        this.mediaStream.getMediaStreamStats().updateNewSentFeedback(feedback);
        if (!logger.isInfoEnabled())         return pkt;
        long jitter=feedback.getJitter();
        if (jitter < getMinInterArrivalJitter() || getMinInterArrivalJitter() == -1)         minInterArrivalJitter=jitter;
        if (getMaxInterArrivalJitter() < jitter)         maxInterArrivalJitter=jitter;
        lost=feedback.getNumLost();
        if (numberOfSenderReports % 4 != 1)         return pkt;
        StringBuilder buff=new StringBuilder(RTP_STAT_PREFIX);
        MediaFormat mediaStreamFormat=mediaStream.getFormat();
        buff.append("Sending a report for ").append(mediaStreamFormat != null ? mediaStreamFormat.getMediaType() : "").append(" stream SSRC:").append(feedback.getSSRC()).append(" [packet count:").append(report.getSenderPacketCount()).append(", bytes:").append(report.getSenderByteCount()).append(", interarrival jitter:").append(jitter).append(", lost packets:").append(feedback.getNumLost()).append(", time since previous report:").append((int)(feedback.getDLSR() / 65.536)).append("ms ]");
        logger.info(buff);
      }
    }
  }
 catch (  Throwable t) {
    t.printStackTrace();
  }
  return pkt;
}
