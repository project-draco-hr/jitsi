{
  CaptureDeviceInfo[] captureDeviceInfos;
  List<MediaDeviceImpl> privateDevices;
switch (mediaType) {
case AUDIO:
    captureDeviceInfos=getDeviceConfiguration().getAvailableAudioCaptureDevices();
  privateDevices=audioDevices;
break;
case VIDEO:
captureDeviceInfos=getDeviceConfiguration().getAvailableVideoCaptureDevices();
privateDevices=videoDevices;
break;
default :
return EMPTY_DEVICES;
}
List<MediaDevice> publicDevices=new ArrayList<MediaDevice>();
synchronized (privateDevices) {
if ((captureDeviceInfos == null) || (captureDeviceInfos.length == 0)) privateDevices.clear();
 else {
Iterator<MediaDeviceImpl> deviceIter=privateDevices.iterator();
while (deviceIter.hasNext()) {
CaptureDeviceInfo captureDeviceInfo=deviceIter.next().getCaptureDeviceInfo();
boolean deviceIsFound=false;
for (int i=0; i < captureDeviceInfos.length; i++) if (captureDeviceInfo.equals(captureDeviceInfos[i])) {
deviceIsFound=true;
captureDeviceInfos[i]=null;
break;
}
if (!deviceIsFound) deviceIter.remove();
}
for (CaptureDeviceInfo captureDeviceInfo : captureDeviceInfos) {
if (captureDeviceInfo == null) continue;
MediaDeviceImpl device;
switch (mediaType) {
case AUDIO:
device=new AudioMediaDeviceImpl(captureDeviceInfo);
break;
case VIDEO:
device=new MediaDeviceImpl(captureDeviceInfo,mediaType);
break;
default :
device=null;
break;
}
if (device != null) privateDevices.add(device);
}
}
publicDevices=new ArrayList<MediaDevice>(privateDevices);
}
if (publicDevices.isEmpty()) {
MediaDevice nonSendDevice;
switch (mediaType) {
case AUDIO:
nonSendDevice=getNonSendAudioDevice();
break;
case VIDEO:
nonSendDevice=getNonSendVideoDevice();
break;
default :
nonSendDevice=null;
break;
}
if (nonSendDevice != null) publicDevices.add(nonSendDevice);
}
return publicDevices;
}
