{
  long low_Q16, high_Q16;
  long base_tmp, range_Q32;
  long base_Q32=psRC.base_Q32;
  long range_Q16=psRC.range_Q16;
  int bufferIx=psRC.bufferIx;
  byte[] buffer=psRC.buffer;
  int buffer_offset=4;
  if (psRC.error != 0) {
    data[data_offset + 0]=0;
    return;
  }
  high_Q16=prob[prob_offset + probIx];
  base_tmp=(range_Q16 * high_Q16) & 0xFFFFFFFFL;
  if (base_tmp > base_Q32) {
    while (true) {
      low_Q16=prob[--probIx + prob_offset];
      base_tmp=(range_Q16 * low_Q16) & 0xFFFFFFFFL;
      if (base_tmp <= base_Q32) {
        break;
      }
      high_Q16=low_Q16;
      if (high_Q16 == 0) {
        psRC.error=Silk_define.RANGE_CODER_CDF_OUT_OF_RANGE;
        data[data_offset + 0]=0;
        return;
      }
    }
  }
 else {
    while (true) {
      low_Q16=high_Q16;
      high_Q16=prob[++probIx + prob_offset];
      base_tmp=(range_Q16 * high_Q16) & 0xFFFFFFFFL;
      if (base_tmp > base_Q32) {
        probIx--;
        break;
      }
      if (high_Q16 == 0xFFFF) {
        psRC.error=Silk_define.RANGE_CODER_CDF_OUT_OF_RANGE;
        data[data_offset + 0]=0;
        return;
      }
    }
  }
  data[data_offset + 0]=probIx;
  base_Q32-=(range_Q16 * low_Q16) & 0xFFFFFFFFL;
  base_Q32=base_Q32 & 0xFFFFFFFFL;
  range_Q32=(range_Q16 * (high_Q16 - low_Q16)) & 0xFFFFFFFFL;
  range_Q32=range_Q32 & 0xFFFFFFFFL;
  if ((range_Q32 & 0xFF000000L) != 0) {
    range_Q16=range_Q32 >>> 16;
  }
 else {
    if ((range_Q32 & 0xFFFF0000L) != 0) {
      range_Q16=(range_Q32 >>> 8);
      if ((base_Q32 >>> 24) != 0) {
        psRC.error=Silk_define.RANGE_CODER_NORMALIZATION_FAILED;
        data[data_offset + 0]=0;
        return;
      }
    }
 else {
      range_Q16=range_Q32;
      if ((base_Q32 >>> 16) != 0) {
        psRC.error=Silk_define.RANGE_CODER_NORMALIZATION_FAILED;
        data[data_offset + 0]=0;
        return;
      }
      base_Q32=(base_Q32 << 8);
      base_Q32=base_Q32 & 0xFFFFFFFFL;
      if (bufferIx < psRC.bufferLength) {
        base_Q32|=(buffer[buffer_offset + bufferIx++]) & 0xFF;
      }
    }
    base_Q32=(base_Q32 << 8);
    base_Q32=base_Q32 & 0xFFFFFFFFL;
    if (bufferIx < psRC.bufferLength) {
      base_Q32|=(buffer[buffer_offset + bufferIx++]) & 0xFF;
    }
  }
  if (range_Q16 == 0) {
    psRC.error=Silk_define.RANGE_CODER_ZERO_INTERVAL_WIDTH;
    data[data_offset + 0]=0;
    return;
  }
  psRC.base_Q32=base_Q32;
  psRC.range_Q16=range_Q16;
  psRC.bufferIx=bufferIx;
}
