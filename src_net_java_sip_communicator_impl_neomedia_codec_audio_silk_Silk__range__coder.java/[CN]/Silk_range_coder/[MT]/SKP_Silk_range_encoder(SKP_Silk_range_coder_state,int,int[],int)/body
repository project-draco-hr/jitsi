{
  long low_Q16, high_Q16;
  long base_tmp, range_Q32;
  long base_Q32=psRC.base_Q32;
  long range_Q16=psRC.range_Q16;
  int bufferIx=psRC.bufferIx;
  byte[] buffer=psRC.buffer;
  if (psRC.error != 0) {
    return;
  }
  low_Q16=prob[prob_offset + data];
  high_Q16=prob[prob_offset + data + 1];
  base_tmp=base_Q32;
  base_Q32+=(range_Q16 * low_Q16) & 0xFFFFFFFFL;
  base_Q32=base_Q32 & 0xFFFFFFFFL;
  range_Q32=(range_Q16 * (high_Q16 - low_Q16)) & 0xFFFFFFFFL;
  if (base_Q32 < base_tmp) {
    int bufferIx_tmp=bufferIx;
    while ((++buffer[--bufferIx_tmp]) == 0)     ;
  }
  if ((range_Q32 & 0xFF000000L) != 0) {
    range_Q16=(range_Q32 >>> 16);
  }
 else {
    if ((range_Q32 & 0xFFFF0000L) != 0) {
      range_Q16=(range_Q32 >>> 8);
    }
 else {
      range_Q16=range_Q32;
      if (bufferIx >= psRC.bufferLength) {
        psRC.error=Silk_define.RANGE_CODER_WRITE_BEYOND_BUFFER;
        return;
      }
      buffer[bufferIx++]=(byte)(base_Q32 >>> 24);
      base_Q32=(base_Q32 << 8) & 0xFFFFFFFFL;
    }
    if (bufferIx >= psRC.bufferLength) {
      psRC.error=Silk_define.RANGE_CODER_WRITE_BEYOND_BUFFER;
      return;
    }
    buffer[bufferIx++]=(byte)(base_Q32 >>> 24);
    base_Q32=(base_Q32 << 8) & 0xFFFFFFFFL;
  }
  psRC.base_Q32=base_Q32;
  psRC.range_Q16=range_Q16;
  psRC.bufferIx=bufferIx;
}
