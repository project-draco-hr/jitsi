{
  List<MediaDescription> remoteDescriptions=SdpUtils.extractMediaDescriptions(answer);
  this.setCallInfoURL(SdpUtils.getCallInfoURL(answer));
  boolean masterStreamSet=false;
  List<MediaType> seenMediaTypes=new ArrayList<MediaType>();
  for (  MediaDescription mediaDescription : remoteDescriptions) {
    MediaType mediaType;
    try {
      mediaType=SdpUtils.getMediaType(mediaDescription);
      if (seenMediaTypes.contains(mediaType))       continue;
      seenMediaTypes.add(mediaType);
    }
 catch (    IllegalArgumentException iae) {
      logger.info("Remote party added to answer a media type that " + "we don't understand. Ignoring stream.");
      continue;
    }
    MediaStreamTarget target=SdpUtils.extractDefaultTarget(mediaDescription,answer);
    if (target.getDataAddress().getPort() == 0) {
      closeStream(mediaType);
      continue;
    }
    List<MediaFormat> supportedFormats=SdpUtils.extractFormats(mediaDescription,getDynamicPayloadTypes());
    MediaDevice dev=getDefaultDevice(mediaType);
    if (dev == null) {
      closeStream(mediaType);
      continue;
    }
    MediaDirection devDirection=(dev == null) ? MediaDirection.INACTIVE : dev.getDirection();
    devDirection=devDirection.and(getDirectionUserPreference(mediaType));
    if (supportedFormats.isEmpty()) {
      ProtocolProviderServiceSipImpl.throwOperationFailedException("Remote party sent an invalid SDP answer. The codecs in " + "the answer are either not present or not " + "supported",OperationFailedException.ILLEGAL_ARGUMENT,null,logger);
    }
    StreamConnector connector=getTransportManager().getStreamConnector(mediaType);
    MediaDirection remoteDirection=SdpUtils.getDirection(mediaDescription);
    MediaDirection direction=devDirection.getDirectionForAnswer(remoteDirection);
    if (isLocallyOnHold())     direction=direction.and(MediaDirection.SENDONLY);
    List<RTPExtension> remoteRTPExtensions=SdpUtils.extractRTPExtensions(mediaDescription,getRtpExtensionsRegistry());
    List<RTPExtension> supportedExtensions=getExtensionsForType(mediaType);
    List<RTPExtension> rtpExtensions=intersectRTPExtensions(remoteRTPExtensions,supportedExtensions);
    if (mediaType.equals(MediaType.VIDEO)) {
      supportQualityControls=SdpUtils.containsAttribute(mediaDescription,"imageattr");
    }
    MediaTypeSrtpControl key=new MediaTypeSrtpControl(mediaType,SrtpControlType.SDES);
    SrtpControl scontrol=getSrtpControls().get(key);
    if (scontrol != null) {
      List<String> peerAttributes=new LinkedList<String>();
      @SuppressWarnings("unchecked") Vector<Attribute> attrs=mediaDescription.getAttributes(true);
      for (      Attribute a : attrs) {
        try {
          if (a.getName().equals("crypto")) {
            peerAttributes.add(a.getValue());
          }
        }
 catch (        SdpParseException e) {
          logger.error("received an unparsable sdp attribute",e);
        }
      }
      if (!((SDesControl)scontrol).initiatorSelectAttribute(peerAttributes)) {
        scontrol.cleanup();
        getSrtpControls().remove(key);
        if (peerAttributes.size() > 0)         logger.warn("Received unsupported sdes crypto attribute: " + peerAttributes);
      }
 else {
        Iterator<MediaTypeSrtpControl> it=getSrtpControls().keySet().iterator();
        while (it.hasNext()) {
          MediaTypeSrtpControl mtc=it.next();
          if (mtc.mediaType == mediaType && mtc.srtpControlType != SrtpControlType.SDES) {
            getSrtpControls().get(mtc).cleanup();
            it.remove();
          }
        }
      }
    }
    boolean masterStream=false;
    if (!masterStreamSet) {
      if (remoteDescriptions.size() > 1) {
        if (mediaType.equals(MediaType.AUDIO)) {
          masterStream=true;
          masterStreamSet=true;
        }
      }
 else {
        masterStream=true;
        masterStreamSet=true;
      }
    }
    initStream(connector,dev,supportedFormats.get(0),target,direction,rtpExtensions,masterStream);
  }
}
