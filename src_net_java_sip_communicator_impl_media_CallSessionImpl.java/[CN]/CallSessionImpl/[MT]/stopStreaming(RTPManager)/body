{
  boolean stoppedAtLeastOneStream=stopSendStreaming(rtpManager);
  List<ReceiveStream> receiveStreams;
  try {
    receiveStreams=rtpManager.getReceiveStreams();
  }
 catch (  Exception e) {
    logger.trace("Failed to retrieve receive streams",e);
    receiveStreams=new Vector<ReceiveStream>();
  }
  for (  ReceiveStream stream : receiveStreams) {
    try {
      stream.getDataSource().stop();
    }
 catch (    IOException ex) {
      logger.warn("Failed to stop stream.",ex);
    }
    stoppedAtLeastOneStream=true;
  }
  if (selectedKeyProviderAlgorithm != null && selectedKeyProviderAlgorithm.getProviderType() == KeyProviderAlgorithm.ProviderType.ZRTP_PROVIDER) {
    TransformConnector transConnector=this.transConnectors.get(rtpManager);
    if (transConnector != null) {
      if (usingZRTP) {
        ZRTPTransformEngine engine=(ZRTPTransformEngine)transConnector.getEngine();
        engine.stopZrtp();
        engine.cleanup();
      }
      transConnector.removeTargets();
    }
  }
 else {
    rtpManager.removeTargets("Session ended.");
  }
  printFlowStatistics(rtpManager);
  rtpManager.removeReceiveStreamListener(this);
  rtpManager.removeSendStreamListener(this);
  rtpManager.removeSessionListener(this);
  rtpManager.dispose();
  return stoppedAtLeastOneStream;
}
