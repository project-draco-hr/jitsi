{
  boolean stoppedAtLeastOneStream=false;
  Vector sendStreams=rtpManager.getSendStreams();
  Iterator ssIter=sendStreams.iterator();
  while (ssIter.hasNext()) {
    SendStream stream=(SendStream)ssIter.next();
    try {
      stream.getDataSource().stop();
      stream.stop();
      stream.close();
    }
 catch (    IOException ex) {
      logger.warn("Failed to stop stream.",ex);
    }
    stoppedAtLeastOneStream=true;
  }
  Vector receiveStreams=rtpManager.getReceiveStreams();
  Iterator rsIter=receiveStreams.iterator();
  while (rsIter.hasNext()) {
    ReceiveStream stream=(ReceiveStream)rsIter.next();
    try {
      stream.getDataSource().stop();
    }
 catch (    IOException ex) {
      logger.warn("Failed to stop stream.",ex);
    }
    stoppedAtLeastOneStream=true;
  }
  if (selectedKeyProviderAlgorithm != null && rtpManager.equals(audioRtpManager)) {
    TransformConnector transConnector=this.transConnectors.get(rtpManager);
    if (transConnector != null) {
      ZRTPTransformEngine engine=(ZRTPTransformEngine)transConnector.getEngine();
      engine.sendInfo(ZrtpCodes.MessageSeverity.Info,EnumSet.of(ZRTPCustomInfoCodes.ZRTPDisabledByCallEnd));
      transConnector.removeTargets();
    }
  }
 else {
    rtpManager.removeTargets("Session ended.");
  }
  printFlowStatistics(rtpManager);
  rtpManager.removeReceiveStreamListener(this);
  rtpManager.removeSendStreamListener(this);
  rtpManager.removeSessionListener(this);
  rtpManager.dispose();
  return stoppedAtLeastOneStream;
}
