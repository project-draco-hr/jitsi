{
  boolean stoppedAtLeastOneStream=false;
  Vector<SendStream> sendStreams=rtpManager.getSendStreams();
  Iterator<SendStream> ssIter=sendStreams.iterator();
  while (ssIter.hasNext()) {
    SendStream stream=(SendStream)ssIter.next();
    try {
      stream.getDataSource().stop();
      stream.stop();
      stream.close();
    }
 catch (    IOException ex) {
      logger.warn("Failed to stop stream.",ex);
    }
    stoppedAtLeastOneStream=true;
  }
  Vector<ReceiveStream> receiveStreams=rtpManager.getReceiveStreams();
  Iterator<ReceiveStream> rsIter=receiveStreams.iterator();
  while (rsIter.hasNext()) {
    ReceiveStream stream=rsIter.next();
    try {
      stream.getDataSource().stop();
    }
 catch (    IOException ex) {
      logger.warn("Failed to stop stream.",ex);
    }
    stoppedAtLeastOneStream=true;
  }
  if (selectedKeyProviderAlgorithm != null && selectedKeyProviderAlgorithm.getProviderType() == KeyProviderAlgorithm.ProviderType.ZRTP_PROVIDER) {
    TransformConnector transConnector=this.transConnectors.get(rtpManager);
    if (transConnector != null) {
      ZRTPTransformEngine engine=(ZRTPTransformEngine)transConnector.getEngine();
      engine.stopZrtp();
      engine.cleanup();
      transConnector.removeTargets();
    }
  }
 else {
    rtpManager.removeTargets("Session ended.");
  }
  printFlowStatistics(rtpManager);
  rtpManager.removeReceiveStreamListener(this);
  rtpManager.removeSendStreamListener(this);
  rtpManager.removeSessionListener(this);
  rtpManager.dispose();
  return stoppedAtLeastOneStream;
}
