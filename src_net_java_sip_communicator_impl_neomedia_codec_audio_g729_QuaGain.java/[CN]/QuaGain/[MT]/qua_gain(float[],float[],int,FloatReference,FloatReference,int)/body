{
  float FLT_MAX_G729=Ld8k.FLT_MAX_G729;
  float GP0999=Ld8k.GP0999;
  float GPCLIP2=Ld8k.GPCLIP2;
  int NCAN1=Ld8k.NCAN1;
  int NCAN2=Ld8k.NCAN2;
  int NCODE2=Ld8k.NCODE2;
  float[][] gbk1=TabLd8k.gbk1;
  float[][] gbk2=TabLd8k.gbk2;
  int[] map1=TabLd8k.map1;
  int[] map2=TabLd8k.map2;
  int i, j, index1=0, index2=0;
  int cand1, cand2;
  float gcode0;
  float dist, dist_min, g_pitch, g_code;
  float[] best_gain=new float[2];
  float tmp;
  gcode0=Gainpred.gain_predict(past_qua_en,code,l_subfr);
  tmp=-1.f / (4.f * g_coeff[0] * g_coeff[2] - g_coeff[4] * g_coeff[4]);
  best_gain[0]=(2.f * g_coeff[2] * g_coeff[1] - g_coeff[3] * g_coeff[4]) * tmp;
  best_gain[1]=(2.f * g_coeff[0] * g_coeff[3] - g_coeff[1] * g_coeff[4]) * tmp;
  if (tameflag == 1) {
    if (best_gain[0] > GPCLIP2)     best_gain[0]=GPCLIP2;
  }
  IntReference cand1Ref=new IntReference();
  IntReference cand2Ref=new IntReference();
  gbk_presel(best_gain,cand1Ref,cand2Ref,gcode0);
  cand1=cand1Ref.value;
  cand2=cand2Ref.value;
  dist_min=FLT_MAX_G729;
  if (tameflag == 1) {
    for (i=0; i < NCAN1; i++) {
      for (j=0; j < NCAN2; j++) {
        g_pitch=gbk1[cand1 + i][0] + gbk2[cand2 + j][0];
        if (g_pitch < GP0999) {
          g_code=gcode0 * (gbk1[cand1 + i][1] + gbk2[cand2 + j][1]);
          dist=g_pitch * g_pitch * g_coeff[0] + g_pitch * g_coeff[1] + g_code * g_code * g_coeff[2] + g_code * g_coeff[3] + g_pitch * g_code * g_coeff[4];
          if (dist < dist_min) {
            dist_min=dist;
            index1=cand1 + i;
            index2=cand2 + j;
          }
        }
      }
    }
  }
 else {
    for (i=0; i < NCAN1; i++) {
      for (j=0; j < NCAN2; j++) {
        g_pitch=gbk1[cand1 + i][0] + gbk2[cand2 + j][0];
        g_code=gcode0 * (gbk1[cand1 + i][1] + gbk2[cand2 + j][1]);
        dist=g_pitch * g_pitch * g_coeff[0] + g_pitch * g_coeff[1] + g_code * g_code * g_coeff[2] + g_code * g_coeff[3] + g_pitch * g_code * g_coeff[4];
        if (dist < dist_min) {
          dist_min=dist;
          index1=cand1 + i;
          index2=cand2 + j;
        }
      }
    }
  }
  gain_pit.value=gbk1[index1][0] + gbk2[index2][0];
  g_code=gbk1[index1][1] + gbk2[index2][1];
  gain_code.value=g_code * gcode0;
  Gainpred.gain_update(past_qua_en,g_code);
  return (map1[index1] * NCODE2 + map2[index2]);
}
