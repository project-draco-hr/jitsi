{
  String registrarAddressStr=accountID.getAccountPropertyString(ProtocolProviderFactory.SERVER_ADDRESS);
  if (registrarAddressStr == null) {
    String userID=accountID.getAccountPropertyString(ProtocolProviderFactory.USER_ID);
    int index=userID.indexOf('@');
    if (index > -1)     registrarAddressStr=userID.substring(index + 1);
  }
  if (registrarAddressStr == null || registrarAddressStr.trim().length() == 0) {
    initRegistrarlessConnection(accountID);
    return;
  }
  InetSocketAddress[] registrarSocketAddresses=null;
  String registrarTransport=accountID.getAccountPropertyString(ProtocolProviderFactory.PREFERRED_TRANSPORT);
  if (registrarTransport != null && registrarTransport.length() > 0) {
    if (!registrarTransport.equals(ListeningPoint.UDP) && !registrarTransport.equals(ListeningPoint.TCP) && !registrarTransport.equals(ListeningPoint.TLS)) {
      throw new IllegalArgumentException(registrarTransport + " is not a valid transport protocol. Transport must be " + "left blanc or set to TCP, UDP or TLS.");
    }
  }
 else {
    registrarTransport=getDefaultTransport();
  }
  int registrarPort=ListeningPoint.PORT_5060;
  try {
    if (accountID.getAccountProperty(ProtocolProviderFactory.SERVER_PORT) != null) {
      ArrayList<InetSocketAddress> registrarSocketAddressesList=new ArrayList<InetSocketAddress>();
      resolveAddresses(registrarAddressStr,registrarSocketAddressesList,Boolean.getBoolean("java.net.preferIPv6Addresses"),registrarPort);
      registrarSocketAddresses=registrarSocketAddressesList.toArray(new InetSocketAddress[0]);
    }
 else {
      registrarSocketAddresses=resolveSipAddress(registrarAddressStr,registrarTransport);
    }
    if (registrarSocketAddresses != null && registrarSocketAddresses.length > 0)     accountID.putAccountProperty(ProtocolProviderFactory.SERVER_ADDRESS_VALIDATED,Boolean.toString(true));
  }
 catch (  UnknownHostException ex) {
    if (logger.isDebugEnabled())     logger.debug(registrarAddressStr + " appears to be an either invalid" + " or inaccessible address.",ex);
    boolean isServerValidated=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.SERVER_ADDRESS_VALIDATED,false);
    if (!isServerValidated) {
      throw new IllegalArgumentException(registrarAddressStr + " appears to be an either invalid" + " or inaccessible address.",ex);
    }
  }
  if (registrarSocketAddresses == null || registrarSocketAddresses.length == 0) {
    fireRegistrationStateChanged(RegistrationState.UNREGISTERED,RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_SERVER_NOT_FOUND,"Invalid or inaccessible server address.");
    return;
  }
  registrarPort=accountID.getAccountPropertyInt(ProtocolProviderFactory.SERVER_PORT,registrarPort);
  if (registrarPort > NetworkUtils.MAX_PORT_NUMBER) {
    throw new IllegalArgumentException(registrarPort + " is larger than " + NetworkUtils.MAX_PORT_NUMBER+ " and does not therefore represent a valid port number.");
  }
  int expires=SipActivator.getConfigurationService().getInt(REGISTRATION_EXPIRATION,SipRegistrarConnection.DEFAULT_REGISTRATION_EXPIRATION);
  try {
    this.sipRegistrarConnection=new SipRegistrarConnection(registrarSocketAddresses,registrarTransport,expires,this);
  }
 catch (  ParseException ex) {
    logger.error("Failed to create a registrar connection with " + registrarSocketAddresses[0].getAddress().getHostAddress(),ex);
    throw new IllegalArgumentException("Failed to create a registrar connection with " + registrarSocketAddresses[0].getAddress().getHostAddress() + ": "+ ex.getMessage());
  }
}
