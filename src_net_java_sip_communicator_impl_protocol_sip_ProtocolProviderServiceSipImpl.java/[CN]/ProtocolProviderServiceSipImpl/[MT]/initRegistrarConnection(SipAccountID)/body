{
  String registrarAddressStr=accountID.getAccountPropertyString(ProtocolProviderFactory.SERVER_ADDRESS);
  if (registrarAddressStr == null) {
    String userID=accountID.getAccountPropertyString(ProtocolProviderFactory.USER_ID);
    int index=userID.indexOf("@");
    if (index > -1)     registrarAddressStr=userID.substring(index + 1);
  }
  if (registrarAddressStr == null || registrarAddressStr.trim().length() == 0) {
    initRegistrarlessConnection(accountID);
    return;
  }
  InetAddress registrarAddress=null;
  int registrarPort=ListeningPoint.PORT_5060;
  try {
    String registrarTransport=accountID.getAccountPropertyString(ProtocolProviderFactory.PREFERRED_TRANSPORT);
    if (registrarTransport == null)     registrarTransport=getDefaultTransport();
    InetSocketAddress registrarSocketAddress=resolveSipAddress(registrarAddressStr,registrarTransport);
    registrarAddress=registrarSocketAddress.getAddress();
    registrarPort=registrarSocketAddress.getPort();
    accountID.putAccountProperty(ProtocolProviderFactory.SERVER_ADDRESS_VALIDATED,Boolean.toString(true));
  }
 catch (  UnknownHostException ex) {
    logger.debug(registrarAddressStr + " appears to be an either invalid" + " or inaccessible address.",ex);
    boolean isServerValidated=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.SERVER_ADDRESS_VALIDATED,false);
    if (!isServerValidated) {
      throw new IllegalArgumentException(registrarAddressStr + " appears to be an either invalid" + " or inaccessible address.",ex);
    }
  }
  if (registrarAddress == null) {
    fireRegistrationStateChanged(RegistrationState.UNREGISTERED,RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_SERVER_NOT_FOUND,"Invalid or inaccessible server address.");
    return;
  }
  registrarPort=accountID.getAccountPropertyInt(ProtocolProviderFactory.SERVER_PORT,registrarPort);
  if (registrarPort > NetworkUtils.MAX_PORT_NUMBER) {
    throw new IllegalArgumentException(registrarPort + " is larger than " + NetworkUtils.MAX_PORT_NUMBER+ " and does not therefore represent a valid port nubmer.");
  }
  String registrarTransport=accountID.getAccountPropertyString(ProtocolProviderFactory.PREFERRED_TRANSPORT);
  if (registrarTransport != null && registrarTransport.length() > 0) {
    if (!registrarTransport.equals(ListeningPoint.UDP) && !registrarTransport.equals(ListeningPoint.TCP) && !registrarTransport.equals(ListeningPoint.TLS)) {
      throw new IllegalArgumentException(registrarTransport + " is not a valid transport protocol. Transport must be " + "left blanc or set to TCP, UDP or TLS.");
    }
  }
 else {
    registrarTransport=ListeningPoint.UDP;
  }
  int expires=SipActivator.getConfigurationService().getInt(REGISTRATION_EXPIRATION,SipRegistrarConnection.DEFAULT_REGISTRATION_EXPIRATION);
  try {
    this.sipRegistrarConnection=new SipRegistrarConnection(registrarAddress,registrarPort,registrarTransport,expires,this);
    boolean useRoute=accountID.getAccountPropertyBoolean(REGISTERS_USE_ROUTE,false);
    this.sipRegistrarConnection.setRouteHeaderEnabled(useRoute);
  }
 catch (  ParseException ex) {
    logger.error("Failed to create a registrar connection with " + registrarAddress.getHostAddress(),ex);
    throw new IllegalArgumentException("Failed to create a registrar connection with " + registrarAddress.getHostAddress() + ": "+ ex.getMessage());
  }
}
