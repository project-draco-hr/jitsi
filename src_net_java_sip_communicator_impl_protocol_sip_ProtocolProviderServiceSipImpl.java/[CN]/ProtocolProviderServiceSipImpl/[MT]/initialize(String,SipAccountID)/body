{
synchronized (initializationLock) {
    this.accountID=accountID;
    String protocolIconPath=accountID.getAccountPropertyString(ProtocolProviderFactory.PROTOCOL_ICON_PATH);
    if (protocolIconPath == null)     protocolIconPath="resources/images/protocol/sip";
    this.protocolIcon=new ProtocolIconSipImpl(protocolIconPath);
    this.sipStatusEnum=new SipStatusEnum(protocolIconPath);
    initOutboundProxy(accountID);
    int preferredSipPort=ListeningPoint.PORT_5060;
    String proxyPortStr=SipActivator.getConfigurationService().getString(PREFERRED_SIP_PORT);
    if (proxyPortStr != null && proxyPortStr.length() > 0) {
      try {
        preferredSipPort=Integer.parseInt(proxyPortStr);
      }
 catch (      NumberFormatException ex) {
        logger.error(proxyPortStr + " is not a valid port value. Expected an integer",ex);
      }
      if (preferredSipPort > NetworkUtils.MAX_PORT_NUMBER) {
        logger.error(preferredSipPort + " is larger than " + NetworkUtils.MAX_PORT_NUMBER+ " and does not "+ "therefore represent a valid port number.");
      }
    }
    if (sipStackSharing == null)     sipStackSharing=new SipStackSharing();
    boolean enablePresence=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.IS_PRESENCE_ENABLED,true);
    boolean forceP2P=accountID.getAccountPropertyBoolean(ProtocolProviderFactory.FORCE_P2P_MODE,true);
    int pollingValue=accountID.getAccountPropertyInt(ProtocolProviderFactory.POLLING_PERIOD,30);
    int subscriptionExpiration=accountID.getAccountPropertyInt(ProtocolProviderFactory.SUBSCRIPTION_EXPIRATION,3600);
    headerFactory=new HeaderFactoryImpl();
    addressFactory=new AddressFactoryImpl();
    ourDisplayName=accountID.getAccountPropertyString(ProtocolProviderFactory.DISPLAY_NAME);
    if (ourDisplayName == null || ourDisplayName.trim().length() == 0) {
      ourDisplayName=accountID.getUserID();
    }
    initRegistrarConnection(accountID);
    OperationSetBasicTelephonySipImpl opSetBasicTelephonySipImpl=new OperationSetBasicTelephonySipImpl(this);
    addSupportedOperationSet(OperationSetBasicTelephony.class,opSetBasicTelephonySipImpl);
    addSupportedOperationSet(OperationSetAdvancedTelephony.class,opSetBasicTelephonySipImpl);
    addSupportedOperationSet(OperationSetSecureTelephony.class,opSetBasicTelephonySipImpl);
    OperationSetPersistentPresence opSetPersPresence=new OperationSetPresenceSipImpl(this,enablePresence,forceP2P,pollingValue,subscriptionExpiration);
    addSupportedOperationSet(OperationSetPersistentPresence.class,opSetPersPresence);
    addSupportedOperationSet(OperationSetPresence.class,opSetPersPresence);
    if (enablePresence) {
      OperationSetBasicInstantMessagingSipImpl opSetBasicIM=new OperationSetBasicInstantMessagingSipImpl(this);
      addSupportedOperationSet(OperationSetBasicInstantMessaging.class,opSetBasicIM);
      addSupportedOperationSet(OperationSetTypingNotifications.class,new OperationSetTypingNotificationsSipImpl(this,opSetBasicIM));
    }
    addSupportedOperationSet(OperationSetVideoTelephony.class,new OperationSetVideoTelephonySipImpl(opSetBasicTelephonySipImpl));
    addSupportedOperationSet(OperationSetDTMF.class,new OperationSetDTMFSipImpl(this));
    addSupportedOperationSet(OperationSetTelephonyConferencing.class,new OperationSetTelephonyConferencingSipImpl(this));
    new ClientCapabilities(this);
    this.sipSecurityManager=new SipSecurityManager(accountID);
    sipSecurityManager.setHeaderFactory(headerFactory);
    ProtocolProviderExtensions.registerCustomOperationSets(this);
    isInitialized=true;
  }
}
