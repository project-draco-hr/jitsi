{
  String branchID=challengedTransaction.getBranchId();
  Request challengedRequest=challengedTransaction.getRequest();
  Request reoriginatedRequest=(Request)challengedRequest.clone();
  ListIterator authHeaders=null;
  if (challenge == null || reoriginatedRequest == null)   throw new NullPointerException("A null argument was passed to handle challenge.");
  if (challenge.getStatusCode() == Response.UNAUTHORIZED)   authHeaders=challenge.getHeaders(WWWAuthenticateHeader.NAME);
 else   if (challenge.getStatusCode() == Response.PROXY_AUTHENTICATION_REQUIRED)   authHeaders=challenge.getHeaders(ProxyAuthenticateHeader.NAME);
  if (authHeaders == null)   throw new NullPointerException("Could not find WWWAuthenticate or ProxyAuthenticate headers");
  reoriginatedRequest.removeHeader(AuthorizationHeader.NAME);
  reoriginatedRequest.removeHeader(ProxyAuthorizationHeader.NAME);
  CSeqHeader cSeq=(CSeqHeader)reoriginatedRequest.getHeader((CSeqHeader.NAME));
  cSeq.setSeqNumber(cSeq.getSeqNumber() + 1l);
  ClientTransaction retryTran=transactionCreator.getNewClientTransaction(reoriginatedRequest);
  WWWAuthenticateHeader authHeader=null;
  while (authHeaders.hasNext()) {
    authHeader=(WWWAuthenticateHeader)authHeaders.next();
    String realm=authHeader.getRealm();
    CredentialsCacheEntry ccEntry=(CredentialsCacheEntry)cachedCredentials.remove(realm);
    UserCredentials defaultCredentials=new UserCredentials();
    FromHeader from=(FromHeader)reoriginatedRequest.getHeader(FromHeader.NAME);
    URI uri=from.getAddress().getURI();
    if (uri.isSipURI()) {
      String user=((SipURI)uri).getUser();
      defaultCredentials.setUserName(user == null ? null : user);
    }
    boolean ccEntryHasSeenTran=false;
    if (ccEntry != null)     ccEntryHasSeenTran=ccEntry.processResponse(branchID);
    if (ccEntry == null || ((ccEntryHasSeenTran && !authHeader.isStale()))) {
      logger.debug("We don't seem to have a good pass! Get one.");
      if (ccEntry == null)       ccEntry=new CredentialsCacheEntry();
      ccEntry.userCredentials=getSecurityAuthority().obtainCredentials(realm,defaultCredentials);
    }
 else     if (ccEntry != null && (!ccEntryHasSeenTran || authHeader.isStale())) {
      logger.debug("We seem to have a pass in the cache. Let's try with it.");
    }
    if (ccEntry.userCredentials == null)     throw new OperationFailedException("Unable to authenticate with realm " + realm,OperationFailedException.GENERAL_ERROR);
    AuthorizationHeader authorization=this.getAuthorization(reoriginatedRequest.getMethod(),reoriginatedRequest.getRequestURI().toString(),reoriginatedRequest.getContent() == null ? "" : reoriginatedRequest.getContent().toString(),authHeader,ccEntry.userCredentials);
    ccEntry.processRequest(retryTran.getBranchId());
    cachedCredentials.cacheEntry(realm,ccEntry);
    logger.debug("Created authorization header: " + authorization.toString());
    reoriginatedRequest.addHeader(authorization);
  }
  logger.debug("Returning authorization transaction.");
  return retryTran;
}
