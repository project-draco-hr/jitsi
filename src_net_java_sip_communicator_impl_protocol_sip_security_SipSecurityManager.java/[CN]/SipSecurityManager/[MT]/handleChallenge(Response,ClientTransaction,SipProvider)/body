{
  String branchID=challengedTransaction.getBranchId();
  Request challengedRequest=challengedTransaction.getRequest();
  Request reoriginatedRequest=(Request)challengedRequest.clone();
  removeBranchID(reoriginatedRequest);
  ListIterator authHeaders=null;
  if (challenge.getStatusCode() == Response.UNAUTHORIZED) {
    authHeaders=challenge.getHeaders(WWWAuthenticateHeader.NAME);
    reoriginatedRequest.removeHeader(AuthorizationHeader.NAME);
  }
 else   if (challenge.getStatusCode() == Response.PROXY_AUTHENTICATION_REQUIRED) {
    authHeaders=challenge.getHeaders(ProxyAuthenticateHeader.NAME);
    reoriginatedRequest.removeHeader(ProxyAuthorizationHeader.NAME);
  }
  CSeqHeader cSeq=(CSeqHeader)reoriginatedRequest.getHeader((CSeqHeader.NAME));
  cSeq.setSeqNumber(cSeq.getSeqNumber() + 1l);
  ClientTransaction retryTran=transactionCreator.getNewClientTransaction(reoriginatedRequest);
  WWWAuthenticateHeader authHeader=null;
  while (authHeaders.hasNext()) {
    authHeader=(WWWAuthenticateHeader)authHeaders.next();
    String realm=authHeader.getRealm();
    CredentialsCacheEntry ccEntry=cachedCredentials.remove(realm);
    boolean ccEntryHasSeenTran=false;
    if (ccEntry != null)     ccEntryHasSeenTran=ccEntry.popBranchID(branchID);
    String storedPassword=SipActivator.getProtocolProviderFactory().loadPassword(accountID);
    if (ccEntry == null) {
      if (storedPassword != null) {
        ccEntry=createCcEntryWithStoredPassword(storedPassword);
        logger.trace("seem to have a stored pass! Try with it.");
      }
 else {
        logger.trace("We don't seem to have a good pass! Get one.");
        ccEntry=createCcEntryWithNewCredentials(realm,SecurityAuthority.AUTHENTICATION_REQUIRED);
        if (ccEntry == null)         throw new OperationFailedException("User has canceled the authentication process.",OperationFailedException.AUTHENTICATION_CANCELED);
      }
    }
 else {
      if (ccEntryHasSeenTran) {
        SipActivator.getProtocolProviderFactory().storePassword(accountID,null);
        ccEntry=createCcEntryWithNewCredentials(realm,SecurityAuthority.WRONG_PASSWORD);
        if (ccEntry == null)         throw new OperationFailedException("User has canceled the authentication process.",OperationFailedException.AUTHENTICATION_CANCELED);
      }
 else {
        logger.trace("We seem to have a pass in the cache. " + "Let's try with it.");
      }
    }
    if (ccEntry == null || ((ccEntryHasSeenTran && !authHeader.isStale()))) {
    }
    if (ccEntry.userCredentials == null) {
      throw new OperationFailedException("Unable to authenticate with realm " + realm + ". User did not provide credentials.",OperationFailedException.AUTHENTICATION_FAILED);
    }
    AuthorizationHeader authorization=this.getAuthorization(reoriginatedRequest.getMethod(),reoriginatedRequest.getRequestURI().toString(),(reoriginatedRequest.getContent() == null) ? "" : reoriginatedRequest.getContent().toString(),authHeader,ccEntry.userCredentials);
    ccEntry.pushBranchID(retryTran.getBranchId());
    cachedCredentials.cacheEntry(realm,ccEntry);
    logger.debug("Created authorization header: " + authorization.toString());
    CallIdHeader call=(CallIdHeader)reoriginatedRequest.getHeader(CallIdHeader.NAME);
    if (call != null) {
      String callid=call.getCallId();
      cachedCredentials.cacheAuthorizationHeader(callid,authorization);
    }
    reoriginatedRequest.addHeader(authorization);
  }
  logger.debug("Returning authorization transaction.");
  return retryTran;
}
