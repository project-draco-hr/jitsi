{
  int k;
  float sum1;
  float diff[]=new float[5];
  final short[] cb_row;
  int cb_row_offset=0;
  rate_dist[0]=Float.MAX_VALUE;
  cb_row=cb;
  cb_row_offset=0;
  for (k=0; k < L; k++) {
    diff[0]=in[in_offset + 0] - cb_row[0] * Silk_define_FLP.Q14_CONVERSION_FAC;
    diff[1]=in[in_offset + 1] - cb_row[1] * Silk_define_FLP.Q14_CONVERSION_FAC;
    diff[2]=in[in_offset + 2] - cb_row[2] * Silk_define_FLP.Q14_CONVERSION_FAC;
    diff[3]=in[in_offset + 3] - cb_row[3] * Silk_define_FLP.Q14_CONVERSION_FAC;
    diff[4]=in[in_offset + 4] - cb_row[4] * Silk_define_FLP.Q14_CONVERSION_FAC;
    sum1=mu * cl_Q6[k] / 64.0f;
    sum1+=diff[0] * (W[W_offset + 0] * diff[0] + 2.0f * (W[W_offset + 1] * diff[1] + W[W_offset + 2] * diff[2] + W[W_offset + 3] * diff[3] + W[W_offset + 4] * diff[4]));
    sum1+=diff[1] * (W[W_offset + 6] * diff[1] + 2.0f * (W[W_offset + 7] * diff[2] + W[W_offset + 8] * diff[3] + W[W_offset + 9] * diff[4]));
    sum1+=diff[2] * (W[W_offset + 12] * diff[2] + 2.0f * (W[W_offset + 13] * diff[3] + W[W_offset + 14] * diff[4]));
    sum1+=diff[3] * (W[W_offset + 18] * diff[3] + 2.0f * (W[W_offset + 19] * diff[4]));
    sum1+=diff[4] * (W[W_offset + 24] * diff[4]);
    if (sum1 < rate_dist[0]) {
      rate_dist[0]=sum1;
      ind[ind_offset + 0]=k;
    }
    cb_row_offset+=Silk_define.LTP_ORDER;
  }
}
