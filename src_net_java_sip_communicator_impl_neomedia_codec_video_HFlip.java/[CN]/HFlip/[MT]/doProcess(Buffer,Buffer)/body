{
  if (outputFilterBufferRef != 0) {
    FFmpeg.avfilter_unref_buffer(outputFilterBufferRef);
    outputFilterBufferRef=0;
  }
  AVFrameFormat format=(AVFrameFormat)inputBuffer.getFormat();
  Dimension size=format.getSize();
  int pixFmt=format.getPixFmt();
  if ((this.width != size.width) || (this.height != size.height) || (this.pixFmt != pixFmt))   reset();
  if (graph == 0) {
    String errorReason=null;
    int error=0;
    long buffer=0;
    long ffsink=0;
    graph=FFmpeg.avfilter_graph_alloc();
    if (graph == 0)     errorReason="avfilter_graph_alloc";
 else {
      String filters=VSRC_BUFFER_NAME + "=" + size.width+ ":"+ size.height+ ":"+ pixFmt+ ":1:1000000:1:1,hflip,"+ VSINK_FFSINK_NAME;
      long log_ctx=0;
      error=FFmpeg.avfilter_graph_parse(graph,filters,0,0,log_ctx);
      if (error == 0) {
        String parsedFilterNameFormat="Parsed filter %1$d %2$s";
        buffer=FFmpeg.avfilter_graph_get_filter(graph,String.format(parsedFilterNameFormat,0,VSRC_BUFFER_NAME));
        if (buffer == 0) {
          errorReason="avfilter_graph_get_filter: " + VSRC_BUFFER_NAME;
        }
 else {
          ffsink=FFmpeg.avfilter_graph_get_filter(graph,String.format(parsedFilterNameFormat,2,VSINK_FFSINK_NAME));
          if (ffsink == 0) {
            errorReason="avfilter_graph_get_filter: " + VSINK_FFSINK_NAME;
          }
 else {
            error=FFmpeg.avfilter_graph_config(graph,log_ctx);
            if (error != 0)             errorReason="avfilter_graph_config";
          }
        }
      }
 else       errorReason="avfilter_graph_parse";
      if ((errorReason != null) || (error != 0)) {
        FFmpeg.avfilter_graph_free(graph);
        graph=0;
      }
    }
    if (graph == 0) {
      if (errorReason != null) {
        if (error == 0)         logger.error(errorReason);
 else         logger.error(errorReason + ": " + error);
      }
      return BUFFER_PROCESSED_FAILED;
    }
 else {
      this.width=size.width;
      this.height=size.height;
      this.pixFmt=pixFmt;
      this.buffer=buffer;
      this.ffsink=ffsink;
    }
  }
  long inputFrame=((AVFrame)inputBuffer.getData()).getPtr();
  outputFilterBufferRef=FFmpeg.get_filtered_video_frame(inputFrame,this.width,this.height,this.pixFmt,buffer,ffsink,outputFrame);
  if (outputFilterBufferRef == 0) {
    if (logger.isDebugEnabled())     logger.debug("get_filtered_video_frame");
    return BUFFER_PROCESSED_FAILED;
  }
  Object out=outputBuffer.getData();
  if (!(out instanceof AVFrame) || (((AVFrame)out).getPtr() != outputFrame)) {
    outputBuffer.setData(new AVFrame(outputFrame));
  }
  outputBuffer.setDiscard(inputBuffer.isDiscard());
  outputBuffer.setDuration(inputBuffer.getDuration());
  outputBuffer.setEOM(inputBuffer.isEOM());
  outputBuffer.setFlags(inputBuffer.getFlags());
  outputBuffer.setFormat(format);
  outputBuffer.setHeader(inputBuffer.getHeader());
  outputBuffer.setLength(inputBuffer.getLength());
  outputBuffer.setSequenceNumber(inputBuffer.getSequenceNumber());
  outputBuffer.setTimeStamp(inputBuffer.getTimeStamp());
  return BUFFER_PROCESSED_OK;
}
