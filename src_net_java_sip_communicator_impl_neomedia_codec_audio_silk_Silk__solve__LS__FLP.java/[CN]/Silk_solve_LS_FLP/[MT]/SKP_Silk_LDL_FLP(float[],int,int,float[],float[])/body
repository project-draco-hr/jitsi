{
  int i, j, k, loop_count, err=1;
  float ptr1[], ptr2[];
  int ptr1_offset, ptr2_offset;
  double temp, diag_min_value;
  float v[]=new float[Silk_define.MAX_MATRIX_SIZE], D[]=new float[Silk_define.MAX_MATRIX_SIZE];
  assert(M <= Silk_define.MAX_MATRIX_SIZE);
  diag_min_value=Silk_define_FLP.FIND_LTP_COND_FAC * 0.5f * (A[A_offset + 0] + A[A_offset + M * M - 1]);
  for (loop_count=0; loop_count < M && err == 1; loop_count++) {
    err=0;
    for (j=0; j < M; j++) {
      ptr1=L;
      ptr1_offset=j * M + 0;
      temp=A[A_offset + j * M + j];
      for (i=0; i < j; i++) {
        v[i]=ptr1[ptr1_offset + i] * D[i];
        temp-=ptr1[ptr1_offset + i] * v[i];
      }
      if (temp < diag_min_value) {
        temp=(loop_count + 1) * diag_min_value - temp;
        for (i=0; i < M; i++) {
          A[A_offset + i * M + i]+=temp;
        }
        err=1;
        break;
      }
      D[j]=(float)temp;
      Dinv[j]=(float)(1.0f / temp);
      L[j * M + j]=1.0f;
      ptr1=A;
      ptr1_offset=A_offset + j * M;
      ptr2=L;
      ptr2_offset=(j + 1) * M;
      for (i=j + 1; i < M; i++) {
        temp=0.0;
        for (k=0; k < j; k++) {
          temp+=ptr2[ptr2_offset + k] * v[k];
        }
        L[i * M + j]=(float)((ptr1[ptr1_offset + i] - temp) * Dinv[j]);
        ptr2_offset+=M;
      }
    }
  }
  assert(err == 0);
}
