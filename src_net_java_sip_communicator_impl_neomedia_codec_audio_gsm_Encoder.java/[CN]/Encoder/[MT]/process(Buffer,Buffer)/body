{
  byte[] inputContent=new byte[inputBuffer.getLength()];
  System.arraycopy(inputBuffer.getData(),inputBuffer.getOffset(),inputContent,0,inputContent.length);
  byte[] mergedContent=mergeArrays((byte[])innerBuffer.getData(),inputContent);
  innerBuffer.setData(mergedContent);
  innerBuffer.setLength(mergedContent.length);
  innerDataLength=innerBuffer.getLength();
  if (TRACE)   dump("input ",inputBuffer);
  if (!checkInputBuffer(inputBuffer)) {
    return BUFFER_PROCESSED_FAILED;
  }
  if (isEOM(inputBuffer)) {
    propagateEOM(outputBuffer);
    return BUFFER_PROCESSED_OK;
  }
  final int result;
  byte[] outputBufferData=(byte[])outputBuffer.getData();
  if (outputBufferData == null || outputBufferData.length < GSM_BYTES * innerDataLength / PCM_BYTES) {
    outputBufferData=new byte[GSM_BYTES * (innerDataLength / PCM_BYTES)];
    outputBuffer.setData(outputBufferData);
  }
  if (innerDataLength < PCM_BYTES) {
    result=OUTPUT_BUFFER_NOT_FILLED;
    System.out.println("Not filled");
  }
 else {
    final boolean bigEndian=((AudioFormat)outputFormat).getEndian() == AudioFormat.BIG_ENDIAN;
    outputBufferData=new byte[GSM_BYTES * (innerDataLength / PCM_BYTES)];
    outputBuffer.setData(outputBufferData);
    outputBuffer.setLength(GSM_BYTES * (innerDataLength / PCM_BYTES));
    GSMEncoderUtil.gsmEncode(bigEndian,(byte[])innerBuffer.getData(),innerBuffer.getOffset(),innerDataLength,outputBufferData);
    outputBuffer.setFormat(outputFormat);
    outputBuffer.setData(outputBufferData);
    result=BUFFER_PROCESSED_OK;
    byte[] temp=new byte[innerDataLength - (innerDataLength / PCM_BYTES) * PCM_BYTES];
    innerContent=(byte[])innerBuffer.getData();
    System.arraycopy(innerContent,(innerDataLength / PCM_BYTES) * PCM_BYTES,temp,0,temp.length);
    outputBuffer.setOffset(0);
    innerBuffer.setLength(temp.length);
    innerBuffer.setData(temp);
  }
  if (TRACE) {
    dump("input ",inputBuffer);
    dump("output",outputBuffer);
  }
  return result;
}
