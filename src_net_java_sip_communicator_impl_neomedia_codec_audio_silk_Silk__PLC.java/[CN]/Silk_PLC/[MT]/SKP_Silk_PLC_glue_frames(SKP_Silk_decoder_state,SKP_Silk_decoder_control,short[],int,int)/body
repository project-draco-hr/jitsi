{
  int i, energy_shift;
  int energy;
  int energy_ptr[]=new int[1];
  int energy_shift_ptr[]=new int[1];
  SKP_Silk_PLC_struct psPLC;
  psPLC=psDec.sPLC;
  if (psDec.lossCnt != 0) {
    int[] conc_energy_ptr=new int[1];
    int[] conc_energy_shift_ptr=new int[1];
    Silk_sum_sqr_shift.SKP_Silk_sum_sqr_shift(conc_energy_ptr,conc_energy_shift_ptr,signal,signal_offset,length);
    psPLC.conc_energy=conc_energy_ptr[0];
    psPLC.conc_energy_shift=conc_energy_shift_ptr[0];
    psPLC.last_frame_lost=1;
  }
 else {
    if (psDec.sPLC.last_frame_lost != 0) {
      Silk_sum_sqr_shift.SKP_Silk_sum_sqr_shift(energy_ptr,energy_shift_ptr,signal,signal_offset,length);
      energy=energy_ptr[0];
      energy_shift=energy_shift_ptr[0];
      if (energy_shift > psPLC.conc_energy_shift) {
        psPLC.conc_energy=(psPLC.conc_energy >> energy_shift - psPLC.conc_energy_shift);
      }
 else       if (energy_shift < psPLC.conc_energy_shift) {
        energy=(energy >> psPLC.conc_energy_shift - energy_shift);
      }
      if (energy > psPLC.conc_energy) {
        int frac_Q24, LZ;
        int gain_Q12, slope_Q12;
        LZ=Silk_macros.SKP_Silk_CLZ32(psPLC.conc_energy);
        LZ=LZ - 1;
        psPLC.conc_energy=(psPLC.conc_energy << LZ);
        energy=(energy >> Math.max(24 - LZ,0));
        frac_Q24=(psPLC.conc_energy / Math.max(energy,1));
        gain_Q12=Silk_Inlines.SKP_Silk_SQRT_APPROX(frac_Q24);
        slope_Q12=((1 << 12) - gain_Q12 / length);
        for (i=0; i < length; i++) {
          signal[signal_offset + i]=(short)((gain_Q12 * signal[signal_offset + i]) >> 12);
          gain_Q12+=slope_Q12;
          gain_Q12=Math.min(gain_Q12,(1 << 12));
        }
      }
    }
    psPLC.last_frame_lost=0;
  }
}
