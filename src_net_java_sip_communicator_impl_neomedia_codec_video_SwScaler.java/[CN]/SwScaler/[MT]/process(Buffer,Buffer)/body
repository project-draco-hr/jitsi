{
  if (!checkInputBuffer(input))   return BUFFER_PROCESSED_FAILED;
  if (isEOM(input)) {
    propagateEOM(output);
    return BUFFER_PROCESSED_OK;
  }
  if (input.isDiscard() || frameProcessingControl.isMinimalProcessing()) {
    output.setDiscard(true);
    return BUFFER_PROCESSED_OK;
  }
  VideoFormat inputFormat=(VideoFormat)input.getFormat();
  Format thisInputFormat=getInputFormat();
  if ((inputFormat != thisInputFormat) && !inputFormat.equals(thisInputFormat))   setInputFormat(inputFormat);
  VideoFormat outputFormat=(VideoFormat)getOutputFormat();
  if (outputFormat == null) {
    outputFormat=(VideoFormat)output.getFormat();
    if (outputFormat == null)     return BUFFER_PROCESSED_FAILED;
  }
  Dimension outputSize=outputFormat.getSize();
  int outputWidth=outputSize.width;
  int outputHeight=outputSize.height;
  if ((outputWidth < 2) || (outputHeight < 2))   return OUTPUT_BUFFER_NOT_FILLED;
  int dstFmt;
  int dstLength;
  if (outputFormat instanceof YUVFormat) {
    dstFmt=FFmpeg.PIX_FMT_YUV420P;
    dstLength=(int)(outputWidth * outputHeight * 1.5);
  }
 else {
    dstFmt=FFmpeg.PIX_FMT_RGB32;
    dstLength=(outputWidth * outputHeight * 4);
  }
  Class<?> outputDataType=outputFormat.getDataType();
  Object dst=output.getData();
  if (Format.byteArray.equals(outputDataType)) {
    if (dst == null || ((byte[])dst).length < dstLength)     dst=new byte[dstLength];
  }
 else   if (Format.intArray.equals(outputDataType)) {
    dstLength=dstLength / 4 + ((dstLength % 4 == 0) ? 0 : 1);
    if (dst == null || ((int[])dst).length < dstLength)     dst=new int[dstLength];
  }
 else   if (Format.shortArray.equals(outputDataType)) {
    dstLength=dstLength / 2 + ((dstLength % 2 == 0) ? 0 : 1);
    if (dst == null || ((short[])dst).length < dstLength)     dst=new short[dstLength];
  }
 else {
    logger.error("Unknown data type " + outputDataType);
    return BUFFER_PROCESSED_FAILED;
  }
  Dimension inputSize=inputFormat.getSize();
  int inputWidth=inputSize.width;
  int inputHeight=inputSize.height;
  Object src=input.getData();
  int srcFmt;
  long srcPicture;
  if (src instanceof AVFrame) {
    srcFmt=((AVFrameFormat)inputFormat).getPixFmt();
    srcPicture=((AVFrame)src).getPtr();
  }
 else {
    srcFmt=(inputFormat instanceof YUVFormat) ? FFmpeg.PIX_FMT_YUV420P : getNativeRGBFormat((RGBFormat)inputFormat);
    srcPicture=0;
  }
  swsContext=FFmpeg.sws_getCachedContext(swsContext,inputWidth,inputHeight,srcFmt,outputWidth,outputHeight,dstFmt,FFmpeg.SWS_BICUBIC);
  if (srcPicture == 0) {
    FFmpeg.sws_scale(swsContext,src,srcFmt,inputWidth,inputHeight,0,inputHeight,dst,dstFmt,outputWidth,outputHeight);
  }
 else {
    FFmpeg.sws_scale(swsContext,srcPicture,0,inputHeight,dst,dstFmt,outputWidth,outputHeight);
  }
  output.setData(dst);
  output.setDuration(input.getDuration());
  output.setFlags(input.getFlags());
  output.setFormat(outputFormat);
  output.setLength(dstLength);
  output.setOffset(0);
  output.setSequenceNumber(input.getSequenceNumber());
  output.setTimeStamp(input.getTimeStamp());
  int inFlags=input.getFlags();
  int outFlags=output.getFlags();
  if ((inFlags & Buffer.FLAG_LIVE_DATA) != 0)   outFlags|=Buffer.FLAG_LIVE_DATA;
  if ((inFlags & Buffer.FLAG_NO_WAIT) != 0)   outFlags|=Buffer.FLAG_NO_WAIT;
  if ((inFlags & Buffer.FLAG_RELATIVE_TIME) != 0)   outFlags|=Buffer.FLAG_RELATIVE_TIME;
  if ((inFlags & Buffer.FLAG_RTP_TIME) != 0)   outFlags|=Buffer.FLAG_RTP_TIME;
  if ((inFlags & Buffer.FLAG_SYSTEM_TIME) != 0)   outFlags|=Buffer.FLAG_SYSTEM_TIME;
  output.setFlags(outFlags);
  return BUFFER_PROCESSED_OK;
}
