{
  long sequenceNumber=inBuffer.getSequenceNumber();
  if ((lastSequenceNumber != -1) && ((sequenceNumber - lastSequenceNumber) != 1)) {
    int ret=0;
    if (logger.isTraceEnabled())     logger.trace("Dropped RTP packets upto sequenceNumber " + lastSequenceNumber + " and continuing with sequenceNumber "+ sequenceNumber);
    ret=reset(outBuffer);
    if ((ret & OUTPUT_BUFFER_NOT_FILLED) == 0) {
      lastSequenceNumber=-1;
      return ret;
    }
  }
  lastSequenceNumber=sequenceNumber;
  byte[] in=(byte[])inBuffer.getData();
  int inLength=inBuffer.getLength();
  int inOffset=inBuffer.getOffset();
  int outOffset=outBuffer.getOffset();
  if (inLength < 3) {
    return BUFFER_PROCESSED_FAILED;
  }
  boolean pBit=((in[inOffset] & 0x04) > 0);
  boolean vBit=((in[inOffset] & 0x02) > 0);
  ;
  int plen=((in[inOffset] & 0x01) << 5) + ((in[inOffset + 1] & 0xF8) >> 3);
  int dataLength=inLength - plen - (vBit ? 1 : 0)- (pBit ? 0 : 2);
  byte out[]=validateByteArraySize(outBuffer,outOffset + dataLength + outputPaddingSize);
  if (pBit) {
    out[0]=0x00;
    out[1]=0x00;
  }
  if (vBit) {
  }
  if (plen > 0) {
    if (logger.isInfoEnabled()) {
      logger.info("Extra picture header present PLEN=" + plen);
    }
  }
  System.arraycopy(in,inOffset + 2 + (vBit ? 1 : 0)+ plen,out,outOffset + (pBit ? 2 : 0),dataLength - (pBit ? 2 : 0));
  padOutput(out,outOffset + dataLength);
  outBuffer.setLength(outOffset + dataLength);
  outBuffer.setSequenceNumber(sequenceNumber);
  if ((inBuffer.getFlags() & Buffer.FLAG_RTP_MARKER) != 0) {
    outBuffer.setFlags(outBuffer.getFlags() | Buffer.FLAG_RTP_MARKER);
    outBuffer.setOffset(0);
    return BUFFER_PROCESSED_OK;
  }
 else {
    outBuffer.setOffset(outOffset + dataLength);
    return OUTPUT_BUFFER_NOT_FILLED;
  }
}
