{
  if (this.presenceEnabled == false)   return false;
  ServerTransaction serverTransaction=requestEvent.getServerTransaction();
  SipProvider jainSipProvider=(SipProvider)requestEvent.getSource();
  Request request=requestEvent.getRequest();
  if (serverTransaction == null) {
    try {
      serverTransaction=SipStackSharing.getOrCreateServerTransaction(requestEvent);
    }
 catch (    TransactionAlreadyExistsException ex) {
      logger.error("Failed to create a new server" + "transaction for an incoming request\n" + "(Next message contains the request)",ex);
      return false;
    }
catch (    TransactionUnavailableException ex) {
      logger.error("Failed to create a new server" + "transaction for an incoming request\n" + "(Next message contains the request)",ex);
      return false;
    }
  }
  EventHeader eventHeader=(EventHeader)request.getHeader(EventHeader.NAME);
  if (eventHeader == null || !eventHeader.getEventType().equalsIgnoreCase("presence")) {
    return false;
  }
  boolean processed=false;
  if (request.getMethod().equals(Request.NOTIFY)) {
    Response response=null;
    logger.debug("notify received");
    SubscriptionStateHeader sstateHeader=(SubscriptionStateHeader)request.getHeader(SubscriptionStateHeader.NAME);
    if (sstateHeader == null) {
      logger.error("no subscription state in this request");
      return false;
    }
    CallIdHeader idheader=(CallIdHeader)request.getHeader(CallIdHeader.NAME);
    ContactSipImpl contact=(ContactSipImpl)this.subscribedContacts.get(idheader.getCallId());
    if (contact != null && !sstateHeader.getState().equalsIgnoreCase(SubscriptionStateHeader.TERMINATED) && !contact.isResolved()) {
      logger.debug("contact still pending while NOTIFY received");
    }
    if (contact == null && !sstateHeader.getState().equalsIgnoreCase(SubscriptionStateHeader.TERMINATED)) {
      logger.debug("contact not found for callid : " + idheader.getCallId());
synchronized (this.waitedCallIds) {
        this.waitedCallIds.remove(idheader.getCallId());
      }
      try {
        response=this.parentProvider.getMessageFactory().createResponse(Response.CALL_OR_TRANSACTION_DOES_NOT_EXIST,request);
      }
 catch (      ParseException e) {
        logger.error("failed to create the 481 response",e);
        return false;
      }
      try {
        serverTransaction.sendResponse(response);
      }
 catch (      SipException e) {
        logger.error("failed to send the response",e);
      }
catch (      InvalidArgumentException e) {
        logger.error("invalid argument provided while trying" + " to send the response",e);
      }
      return true;
    }
    ContentTypeHeader ctheader=(ContentTypeHeader)request.getHeader(ContentTypeHeader.NAME);
    if (ctheader != null && !ctheader.getContentSubType().equalsIgnoreCase(PIDF_XML)) {
      try {
        response=this.parentProvider.getMessageFactory().createResponse(Response.UNSUPPORTED_MEDIA_TYPE,request);
      }
 catch (      ParseException e) {
        logger.error("failed to create the OK response",e);
        return false;
      }
      AcceptHeader acceptHeader=null;
      try {
        acceptHeader=this.parentProvider.getHeaderFactory().createAcceptHeader("application",PIDF_XML);
      }
 catch (      ParseException e) {
        logger.error("failed to create the accept header",e);
        return false;
      }
      response.setHeader(acceptHeader);
      try {
        serverTransaction.sendResponse(response);
      }
 catch (      SipException e) {
        logger.error("failed to send the response",e);
      }
catch (      InvalidArgumentException e) {
        logger.error("invalid argument provided while trying" + " to send the response",e);
      }
    }
    if (sstateHeader.getState().equalsIgnoreCase(SubscriptionStateHeader.TERMINATED)) {
      if (contact != null) {
        terminateSubscription(contact);
        this.subscribedContacts.remove(serverTransaction.getDialog().getCallId().getCallId());
        if (sstateHeader.getReasonCode().equals(SubscriptionStateHeader.DEACTIVATED)) {
          forcePollContact(contact);
        }
      }
synchronized (this.waitedCallIds) {
        this.waitedCallIds.remove(idheader.getCallId());
      }
    }
    try {
      response=this.parentProvider.getMessageFactory().createResponse(Response.OK,request);
    }
 catch (    ParseException e) {
      logger.error("failed to create the OK response",e);
      return false;
    }
    try {
      serverTransaction.sendResponse(response);
    }
 catch (    SipException e) {
      logger.error("failed to send the response",e);
    }
catch (    InvalidArgumentException e) {
      logger.error("invalid argument provided while trying" + " to send the response",e);
    }
    if (request.getRawContent() != null && !sstateHeader.getState().equalsIgnoreCase(SubscriptionStateHeader.TERMINATED)) {
      setPidfPresenceStatus(new String(request.getRawContent()));
    }
    processed=true;
  }
 else   if (request.getMethod().equals(Request.SUBSCRIBE)) {
    FromHeader from=(FromHeader)request.getHeader(FromHeader.NAME);
    if (this.useDistantPA) {
      this.useDistantPA=false;
      if (this.republishTask != null) {
        this.republishTask.cancel();
        this.republishTask=null;
      }
    }
    ContactSipImpl contact=(ContactSipImpl)resolveContactID(from.getAddress().getURI().toString());
    if (contact == null) {
      contact=new ContactSipImpl(from.getAddress(),this.parentProvider);
      contact.setResolved(true);
      contact.setResolvable(false);
    }
    logger.debug(contact.toString() + " wants to watch your presence " + "status");
    ExpiresHeader expHeader=request.getExpires();
    int expires;
    if (expHeader == null) {
      expires=PRESENCE_DEFAULT_EXPIRE;
    }
 else {
      expires=expHeader.getExpires();
    }
    if (expires < SUBSCRIBE_MIN_EXPIRE && expires > 0 && expires < 3600) {
      Response response=null;
      try {
        response=this.parentProvider.getMessageFactory().createResponse(Response.INTERVAL_TOO_BRIEF,request);
      }
 catch (      Exception e) {
        logger.error("Error while creating the response 423",e);
        return false;
      }
      MinExpiresHeader min=null;
      try {
        min=this.parentProvider.getHeaderFactory().createMinExpiresHeader(SUBSCRIBE_MIN_EXPIRE);
      }
 catch (      InvalidArgumentException e) {
        logger.error("can't create the min expires header",e);
        return false;
      }
      response.setHeader(min);
      try {
        serverTransaction.sendResponse(response);
      }
 catch (      Exception e) {
        logger.error("Error while sending the response 423",e);
        return false;
      }
      return true;
    }
    if (this.ourWatchers.contains(contact) && expires != 0 && contact.getServerDialog().equals(serverTransaction.getDialog())) {
      contact.getTimeoutTask().cancel();
      WatcherTimeoutTask timeout=new WatcherTimeoutTask(contact);
      contact.setTimeoutTask(timeout);
      getTimer().schedule(timeout,expires * 1000);
      Response response=null;
      try {
        response=this.parentProvider.getMessageFactory().createResponse(Response.OK,request);
      }
 catch (      Exception e) {
        logger.error("Error while creating the response 200",e);
        return false;
      }
      try {
        expHeader=this.parentProvider.getHeaderFactory().createExpiresHeader(expires);
      }
 catch (      InvalidArgumentException e) {
        logger.error("Can't create the expires header");
        return false;
      }
      response.setHeader(expHeader);
      try {
        serverTransaction.sendResponse(response);
      }
 catch (      Exception e) {
        logger.error("Error while sending the response 200",e);
        return false;
      }
      return true;
    }
    Dialog dialog=contact.getServerDialog();
    if (expires == 0) {
      logger.debug("contact " + contact + " isn't a watcher anymore");
synchronized (this.ourWatchers) {
        this.ourWatchers.remove(contact);
      }
      contact.getTimeoutTask().cancel();
      contact.setServerDialog(null);
      Response response=null;
      try {
        response=this.parentProvider.getMessageFactory().createResponse(Response.OK,request);
      }
 catch (      Exception e) {
        logger.error("Error while creating the response 200",e);
        return false;
      }
      try {
        expHeader=this.parentProvider.getHeaderFactory().createExpiresHeader(0);
      }
 catch (      InvalidArgumentException e) {
        logger.error("Can't create the expires header",e);
        return false;
      }
      response.setHeader(expHeader);
      try {
        serverTransaction.sendResponse(response);
      }
 catch (      Exception e) {
        logger.error("Error while sending the response 200",e);
        return false;
      }
      ClientTransaction transac=null;
      try {
        transac=createNotify(contact,getPidfPresenceStatus((ContactSipImpl)getLocalContactForDst(contact)),SubscriptionStateHeader.TERMINATED,SubscriptionStateHeader.TIMEOUT);
      }
 catch (      OperationFailedException e) {
        logger.error("failed to create the new notify",e);
        return false;
      }
      try {
        dialog.sendRequest(transac);
      }
 catch (      Exception e) {
        logger.error("Can't send the request",e);
        return false;
      }
      return true;
    }
    if (this.ourWatchers.contains(contact) && !contact.getServerDialog().equals(serverTransaction.getDialog())) {
      logger.debug("contact " + contact + " try to resubscribe, "+ "we will remove the first subscription");
      ClientTransaction transac=null;
      try {
        transac=createNotify(contact,getPidfPresenceStatus((ContactSipImpl)getLocalContactForDst(contact)),SubscriptionStateHeader.TERMINATED,SubscriptionStateHeader.REJECTED);
      }
 catch (      OperationFailedException e) {
        logger.error("failed to create the new notify",e);
        return false;
      }
      contact.setServerDialog(null);
synchronized (this.ourWatchers) {
        this.ourWatchers.remove(contact);
      }
      if (contact.getTimeoutTask() != null) {
        contact.getTimeoutTask().cancel();
      }
      try {
        dialog.sendRequest(transac);
      }
 catch (      Exception e) {
        logger.error("Can't send the request",e);
        return false;
      }
    }
synchronized (contact) {
      contact.setServerDialog(serverTransaction.getDialog());
    }
    dialog=contact.getServerDialog();
    Response response=null;
    try {
      response=this.parentProvider.getMessageFactory().createResponse(Response.OK,request);
    }
 catch (    Exception e) {
      logger.error("Error while creating the response 200",e);
      return false;
    }
    try {
      expHeader=this.parentProvider.getHeaderFactory().createExpiresHeader(expires);
    }
 catch (    InvalidArgumentException e) {
      logger.error("Can't create the expires header",e);
      return false;
    }
    response.setHeader(expHeader);
    try {
      serverTransaction.sendResponse(response);
    }
 catch (    Exception e) {
      logger.error("Error while sending the response 200",e);
      return false;
    }
    ClientTransaction transac=null;
    try {
      transac=createNotify(contact,getPidfPresenceStatus((ContactSipImpl)getLocalContactForDst(contact)),SubscriptionStateHeader.ACTIVE,null);
    }
 catch (    OperationFailedException e) {
      logger.error("failed to create the new notify",e);
      return false;
    }
    try {
      dialog.sendRequest(transac);
    }
 catch (    Exception e) {
      logger.error("Can't send the request",e);
      return false;
    }
synchronized (this.ourWatchers) {
      this.ourWatchers.add(contact);
    }
    WatcherTimeoutTask timeout=new WatcherTimeoutTask(contact);
    contact.setTimeoutTask(timeout);
    getTimer().schedule(timeout,expires * 1000);
    processed=true;
  }
 else   if (request.getMethod().equals(Request.PUBLISH)) {
    Response response=null;
    try {
      response=this.parentProvider.getMessageFactory().createResponse(Response.NOT_IMPLEMENTED,request);
    }
 catch (    Exception e) {
      logger.error("Error while creating the response 501",e);
      return false;
    }
    try {
      serverTransaction.sendResponse(response);
    }
 catch (    Exception e) {
      logger.error("Error while sending the response 501",e);
      return false;
    }
    processed=true;
  }
  return processed;
}
