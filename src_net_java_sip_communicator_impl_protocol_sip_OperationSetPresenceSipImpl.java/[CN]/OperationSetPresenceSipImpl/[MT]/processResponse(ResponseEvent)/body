{
  ClientTransaction clientTransaction=responseEvent.getClientTransaction();
  Response response=responseEvent.getResponse();
  CSeqHeader cseq=((CSeqHeader)response.getHeader(CSeqHeader.NAME));
  if (cseq == null) {
    logger.error("An incoming response did not contain a CSeq header");
    return;
  }
  String method=cseq.getMethod();
  SipProvider sourceProvider=(SipProvider)responseEvent.getSource();
  if (method.equals(Request.SUBSCRIBE)) {
    CallIdHeader idheader=(CallIdHeader)response.getHeader(CallIdHeader.NAME);
    ContactSipImpl contact=(ContactSipImpl)this.subscribedContacts.get(idheader.getCallId());
    if (response.getStatusCode() == Response.INTERVAL_TOO_BRIEF) {
      MinExpiresHeader min=(MinExpiresHeader)response.getHeader(MinExpiresHeader.NAME);
      if (min == null) {
        logger.error("no minimal expires value in this 423 " + "response");
        return;
      }
      Request request=responseEvent.getClientTransaction().getRequest();
      ExpiresHeader exp=request.getExpires();
      try {
        exp.setExpires(min.getExpires());
      }
 catch (      InvalidArgumentException e) {
        logger.error("can't set the new expires value",e);
        return;
      }
      ClientTransaction transac=null;
      try {
        transac=this.parentProvider.getDefaultJainSipProvider().getNewClientTransaction(request);
      }
 catch (      TransactionUnavailableException e) {
        logger.error("can't create the client transaction",e);
        return;
      }
      try {
        transac.sendRequest();
      }
 catch (      SipException e) {
        logger.error("can't send the new request",e);
        return;
      }
      return;
    }
    ExpiresHeader expHeader=response.getExpires();
    if ((expHeader != null && expHeader.getExpires() == 0) || contact == null) {
      if (response.getStatusCode() == Response.UNAUTHORIZED || response.getStatusCode() == Response.PROXY_AUTHENTICATION_REQUIRED) {
        try {
          processAuthenticationChallenge(clientTransaction,response,sourceProvider);
        }
 catch (        OperationFailedException e) {
          logger.error("can't handle the challenge");
        }
      }
 else       if (response.getStatusCode() != Response.OK && response.getStatusCode() != Response.ACCEPTED) {
synchronized (this.waitedCallIds) {
          this.waitedCallIds.remove(idheader.getCallId());
        }
      }
      return;
    }
    try {
      if (!contact.isResolved()) {
        finalizeSubscription(contact,clientTransaction.getDialog());
      }
    }
 catch (    NullPointerException e) {
      logger.debug("failed to finalize the subscription of the" + "contact",e);
      return;
    }
    if (response.getStatusCode() == Response.OK || response.getStatusCode() == Response.ACCEPTED) {
      if (expHeader == null) {
        logger.error("no Expires header in this response");
        return;
      }
      RefreshSubscriptionTask refresh=new RefreshSubscriptionTask(contact);
      contact.setResfreshTask(refresh);
      try {
        this.timer.schedule(refresh,expHeader.getExpires() * 1000 - REFRESH_MARGIN);
      }
 catch (      IllegalArgumentException e) {
        logger.debug("the expires value seems to be less than a " + "minute, let's assume it");
        this.timer.schedule(refresh,expHeader.getExpires() * 1000);
      }
      contact.setClientDialog(clientTransaction.getDialog());
    }
 else     if (response.getStatusCode() == Response.UNAUTHORIZED || response.getStatusCode() == Response.PROXY_AUTHENTICATION_REQUIRED) {
      try {
        processAuthenticationChallenge(clientTransaction,response,sourceProvider);
      }
 catch (      OperationFailedException e) {
        logger.error("can't handle the challenge");
        changePresenceStatusForContact(contact,SipStatusEnum.UNKNOWN);
        this.subscribedContacts.remove(idheader.getCallId());
      }
    }
 else     if (response.getStatusCode() == Response.REQUEST_TIMEOUT || response.getStatusCode() == Response.TEMPORARILY_UNAVAILABLE || response.getStatusCode() == Response.BUSY_HERE || response.getStatusCode() == Response.BUSY_EVERYWHERE || response.getStatusCode() == Response.DECLINE) {
      logger.debug("error received from the network" + response);
      if (response.getStatusCode() == Response.TEMPORARILY_UNAVAILABLE) {
        changePresenceStatusForContact(contact,SipStatusEnum.OFFLINE);
      }
 else {
        changePresenceStatusForContact(contact,SipStatusEnum.UNKNOWN);
      }
      this.subscribedContacts.remove(idheader.getCallId());
      contact.setClientDialog(null);
    }
 else {
      logger.debug("error received from the network" + response);
      contact.setResolvable(false);
      changePresenceStatusForContact(contact,SipStatusEnum.UNKNOWN);
      this.subscribedContacts.remove(idheader.getCallId());
      contact.setClientDialog(null);
    }
  }
 else   if (method.equals(Request.NOTIFY)) {
    if (response.getStatusCode() != Response.UNAUTHORIZED && response.getStatusCode() != Response.PROXY_AUTHENTICATION_REQUIRED) {
synchronized (this.waitedCallIds) {
        this.waitedCallIds.remove(((CallIdHeader)response.getHeader(CallIdHeader.NAME)).getCallId());
      }
    }
    if (response.getStatusCode() == Response.OK) {
    }
 else     if (response.getStatusCode() == Response.UNAUTHORIZED || response.getStatusCode() == Response.PROXY_AUTHENTICATION_REQUIRED) {
      try {
        processAuthenticationChallenge(clientTransaction,response,sourceProvider);
      }
 catch (      OperationFailedException e) {
        logger.error("can't handle the challenge");
        String contactAddress=((FromHeader)response.getHeader(FromHeader.NAME)).getAddress().getURI().toString();
        Contact watcher=getWatcher(contactAddress);
        if (watcher != null) {
synchronized (this.ourWatchers) {
            this.ourWatchers.remove(watcher);
          }
        }
      }
    }
 else {
      logger.debug("error received from the network" + response);
      String contactAddress=((FromHeader)response.getHeader(FromHeader.NAME)).getAddress().getURI().toString();
      Contact watcher=getWatcher(contactAddress);
      if (watcher != null) {
synchronized (this.ourWatchers) {
          this.ourWatchers.remove(watcher);
        }
      }
    }
  }
 else   if (method.equals(Request.PUBLISH)) {
    if (response.getStatusCode() != Response.UNAUTHORIZED && response.getStatusCode() != Response.PROXY_AUTHENTICATION_REQUIRED && response.getStatusCode() != Response.INTERVAL_TOO_BRIEF) {
synchronized (this.waitedCallIds) {
        this.waitedCallIds.remove(((CallIdHeader)response.getHeader(CallIdHeader.NAME)).getCallId());
      }
    }
    if (response.getStatusCode() == Response.OK) {
      SIPETagHeader etHeader=(SIPETagHeader)response.getHeader(SIPETagHeader.NAME);
      if (etHeader == null) {
        logger.debug("can't find the ETag header");
        return;
      }
      this.distantPAET=etHeader.getETag();
      ExpiresHeader expires=(ExpiresHeader)response.getHeader(ExpiresHeader.NAME);
      if (expires == null) {
        logger.error("no Expires header in the response");
        return;
      }
      try {
        this.timer.schedule(new RePublishTask(),expires.getExpires() * 1000 - REFRESH_MARGIN);
      }
 catch (      IllegalArgumentException e) {
        logger.debug("the expires value seems to be less than a " + "minute, let's assume it");
        this.timer.schedule(new RePublishTask(),expires.getExpires() * 1000);
      }
    }
 else     if (response.getStatusCode() == Response.UNAUTHORIZED || response.getStatusCode() == Response.PROXY_AUTHENTICATION_REQUIRED) {
      try {
        processAuthenticationChallenge(clientTransaction,response,sourceProvider);
      }
 catch (      OperationFailedException e) {
        logger.error("can't handle the challenge");
        return;
      }
    }
 else     if (response.getStatusCode() == Response.INTERVAL_TOO_BRIEF) {
      MinExpiresHeader min=(MinExpiresHeader)response.getHeader(MinExpiresHeader.NAME);
      if (min == null) {
        logger.error("can't find a min expires header in the 423" + " error message");
        return;
      }
      Request req=null;
      try {
        req=createPublish(min.getExpires(),true);
      }
 catch (      OperationFailedException e) {
        logger.error("can't create the new publish request",e);
        return;
      }
      ClientTransaction transac=null;
      try {
        transac=this.parentProvider.getDefaultJainSipProvider().getNewClientTransaction(req);
      }
 catch (      TransactionUnavailableException e) {
        logger.error("can't create the client transaction",e);
        return;
      }
      try {
        transac.sendRequest();
      }
 catch (      SipException e) {
        logger.error("can't send the PUBLISH request",e);
        return;
      }
    }
 else {
      logger.debug("error received from the network" + response);
      this.distantPAET=null;
    }
  }
}
