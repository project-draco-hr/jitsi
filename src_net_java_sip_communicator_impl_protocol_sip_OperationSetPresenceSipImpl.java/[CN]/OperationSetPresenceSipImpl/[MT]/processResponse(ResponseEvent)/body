{
  if (this.presenceEnabled == false) {
    return false;
  }
  ClientTransaction clientTransaction=responseEvent.getClientTransaction();
  Response response=responseEvent.getResponse();
  CSeqHeader cseq=((CSeqHeader)response.getHeader(CSeqHeader.NAME));
  if (cseq == null) {
    logger.error("An incoming response did not contain a CSeq header");
    return false;
  }
  String method=cseq.getMethod();
  SipProvider sourceProvider=(SipProvider)responseEvent.getSource();
  boolean processed=false;
  if (method.equals(Request.SUBSCRIBE)) {
    CallIdHeader idheader=(CallIdHeader)response.getHeader(CallIdHeader.NAME);
    ContactSipImpl contact=(ContactSipImpl)this.subscribedContacts.get(idheader.getCallId());
    ExpiresHeader expHeader=response.getExpires();
    if ((expHeader != null && expHeader.getExpires() == 0) || contact == null) {
      if (response.getStatusCode() == Response.UNAUTHORIZED || response.getStatusCode() == Response.PROXY_AUTHENTICATION_REQUIRED) {
        try {
          processAuthenticationChallenge(clientTransaction,response,sourceProvider);
          processed=true;
        }
 catch (        OperationFailedException e) {
          logger.error("can't handle the challenge",e);
        }
      }
 else       if (response.getStatusCode() != Response.OK && response.getStatusCode() != Response.ACCEPTED) {
synchronized (this.waitedCallIds) {
          this.waitedCallIds.remove(idheader.getCallId());
        }
        processed=true;
      }
      return processed;
    }
    if (response.getStatusCode() >= Response.OK && response.getStatusCode() < Response.MULTIPLE_CHOICES) {
      if (response.getStatusCode() == Response.OK || response.getStatusCode() == Response.ACCEPTED) {
        if (expHeader == null) {
          logger.error("no Expires header in this response");
          return false;
        }
        if (contact.getResfreshTask() != null) {
          contact.getResfreshTask().cancel();
        }
        RefreshSubscriptionTask refresh=new RefreshSubscriptionTask(contact);
        contact.setResfreshTask(refresh);
        int refreshDelay=expHeader.getExpires();
        if (refreshDelay >= REFRESH_MARGIN)         refreshDelay-=REFRESH_MARGIN;
        getTimer().schedule(refresh,refreshDelay * 1000);
        contact.setClientDialog(clientTransaction.getDialog());
        try {
          if (!contact.isResolved()) {
            if (resolveContactID(contact.getAddress()) == null) {
              ContactGroup parentGroup=contact.getParentContactGroup();
              ((ContactGroupSipImpl)parentGroup).addContact(contact);
              fireSubscriptionEvent(contact,parentGroup,SubscriptionEvent.SUBSCRIPTION_CREATED);
            }
            finalizeSubscription(contact,clientTransaction.getDialog());
          }
        }
 catch (        NullPointerException e) {
          logger.debug("failed to finalize the subscription of the" + "contact",e);
          return false;
        }
      }
    }
 else     if (response.getStatusCode() >= Response.MULTIPLE_CHOICES && response.getStatusCode() < Response.BAD_REQUEST) {
      logger.info("Response to Subscribe of contact: " + contact + " - "+ response.getReasonPhrase());
    }
 else     if (response.getStatusCode() >= Response.BAD_REQUEST) {
      if (response.getStatusCode() == Response.INTERVAL_TOO_BRIEF) {
        MinExpiresHeader min=(MinExpiresHeader)response.getHeader(MinExpiresHeader.NAME);
        if (min == null) {
          logger.error("no minimal expires value in this 423 " + "response");
          return false;
        }
        Request request=responseEvent.getClientTransaction().getRequest();
        ExpiresHeader exp=request.getExpires();
        try {
          exp.setExpires(min.getExpires());
        }
 catch (        InvalidArgumentException e) {
          logger.error("can't set the new expires value",e);
          return false;
        }
        ClientTransaction transac=null;
        try {
          transac=this.parentProvider.getDefaultJainSipProvider().getNewClientTransaction(request);
        }
 catch (        TransactionUnavailableException e) {
          logger.error("can't create the client transaction",e);
          return false;
        }
        try {
          transac.sendRequest();
        }
 catch (        SipException e) {
          logger.error("can't send the new request",e);
          return false;
        }
        return true;
      }
 else       if (response.getStatusCode() == Response.UNAUTHORIZED || response.getStatusCode() == Response.PROXY_AUTHENTICATION_REQUIRED) {
        try {
          processAuthenticationChallenge(clientTransaction,response,sourceProvider);
        }
 catch (        OperationFailedException e) {
          logger.error("can't handle the challenge",e);
          changePresenceStatusForContact(contact,sipStatusEnum.getStatus(SipStatusEnum.UNKNOWN));
          this.subscribedContacts.remove(idheader.getCallId());
          contact.setClientDialog(null);
        }
      }
 else       if (response.getStatusCode() == Response.REQUEST_TIMEOUT || response.getStatusCode() == Response.TEMPORARILY_UNAVAILABLE || response.getStatusCode() == Response.BUSY_HERE || response.getStatusCode() == Response.BUSY_EVERYWHERE || response.getStatusCode() == Response.DECLINE) {
        logger.debug("error received from the network" + response);
        if (response.getStatusCode() == Response.TEMPORARILY_UNAVAILABLE) {
          changePresenceStatusForContact(contact,sipStatusEnum.getStatus(SipStatusEnum.OFFLINE));
        }
 else {
          changePresenceStatusForContact(contact,sipStatusEnum.getStatus(SipStatusEnum.UNKNOWN));
        }
        this.subscribedContacts.remove(idheader.getCallId());
        contact.setClientDialog(null);
        fireSubscriptionEvent(contact,contact.getParentContactGroup(),SubscriptionEvent.SUBSCRIPTION_FAILED,response.getStatusCode(),response.getReasonPhrase());
      }
 else {
        logger.debug("error received from the network" + response);
        contact.setResolvable(false);
        changePresenceStatusForContact(contact,sipStatusEnum.getStatus(SipStatusEnum.UNKNOWN));
        this.subscribedContacts.remove(idheader.getCallId());
        contact.setClientDialog(null);
        fireSubscriptionEvent(contact,contact.getParentContactGroup(),SubscriptionEvent.SUBSCRIPTION_FAILED,response.getStatusCode(),response.getReasonPhrase());
      }
    }
    processed=true;
  }
 else   if (method.equals(Request.NOTIFY)) {
    Request notifyRequest=clientTransaction.getRequest();
    if (notifyRequest != null) {
      EventHeader eventHeader=(EventHeader)notifyRequest.getHeader(EventHeader.NAME);
      if ((eventHeader == null) || !"presence".equalsIgnoreCase(eventHeader.getEventType())) {
        return false;
      }
    }
    if (response.getStatusCode() != Response.UNAUTHORIZED && response.getStatusCode() != Response.PROXY_AUTHENTICATION_REQUIRED) {
synchronized (this.waitedCallIds) {
        this.waitedCallIds.remove(((CallIdHeader)response.getHeader(CallIdHeader.NAME)).getCallId());
      }
    }
    if (response.getStatusCode() == Response.OK) {
    }
 else     if (response.getStatusCode() == Response.UNAUTHORIZED || response.getStatusCode() == Response.PROXY_AUTHENTICATION_REQUIRED) {
      try {
        processAuthenticationChallenge(clientTransaction,response,sourceProvider);
      }
 catch (      OperationFailedException e) {
        logger.error("can't handle the challenge",e);
        String contactAddress=((FromHeader)response.getHeader(FromHeader.NAME)).getAddress().getURI().toString();
        Contact watcher=getWatcher(contactAddress);
        if (watcher != null) {
synchronized (watcher) {
            if (((ContactSipImpl)watcher).getServerDialog().equals(clientTransaction.getDialog())) {
synchronized (this.ourWatchers) {
                this.ourWatchers.remove(watcher);
              }
            }
          }
        }
      }
    }
 else {
      logger.debug("error received from the network" + response);
      String contactAddress=((FromHeader)response.getHeader(FromHeader.NAME)).getAddress().getURI().toString();
      Contact watcher=getWatcher(contactAddress);
      if (watcher != null) {
synchronized (watcher) {
          if (((ContactSipImpl)watcher).getServerDialog().equals(clientTransaction.getDialog())) {
synchronized (this.ourWatchers) {
              this.ourWatchers.remove(watcher);
            }
          }
        }
      }
    }
    processed=true;
  }
 else   if (method.equals(Request.PUBLISH)) {
    if (response.getStatusCode() != Response.UNAUTHORIZED && response.getStatusCode() != Response.PROXY_AUTHENTICATION_REQUIRED && response.getStatusCode() != Response.INTERVAL_TOO_BRIEF) {
synchronized (this.waitedCallIds) {
        this.waitedCallIds.remove(((CallIdHeader)response.getHeader(CallIdHeader.NAME)).getCallId());
      }
    }
    if (response.getStatusCode() == Response.OK) {
      SIPETagHeader etHeader=(SIPETagHeader)response.getHeader(SIPETagHeader.NAME);
      if (etHeader == null) {
        logger.debug("can't find the ETag header");
        return false;
      }
      this.distantPAET=etHeader.getETag();
      ExpiresHeader expires=(ExpiresHeader)response.getHeader(ExpiresHeader.NAME);
      if (expires == null) {
        logger.error("no Expires header in the response");
        return false;
      }
      if (expires.getExpires() == 0) {
        this.distantPAET=null;
        return true;
      }
      if (this.republishTask != null) {
        this.republishTask.cancel();
      }
      this.republishTask=new RePublishTask();
      int republishDelay=expires.getExpires();
      if (republishDelay >= REFRESH_MARGIN)       republishDelay-=REFRESH_MARGIN;
      getTimer().schedule(this.republishTask,republishDelay * 1000);
    }
 else     if (response.getStatusCode() == Response.UNAUTHORIZED || response.getStatusCode() == Response.PROXY_AUTHENTICATION_REQUIRED) {
      try {
        processAuthenticationChallenge(clientTransaction,response,sourceProvider);
      }
 catch (      OperationFailedException e) {
        logger.error("can't handle the challenge",e);
        return false;
      }
    }
 else     if (response.getStatusCode() == Response.INTERVAL_TOO_BRIEF) {
      MinExpiresHeader min=(MinExpiresHeader)response.getHeader(MinExpiresHeader.NAME);
      if (min == null) {
        logger.error("can't find a min expires header in the 423" + " error message");
        return false;
      }
      Request req=null;
      try {
        req=createPublish(min.getExpires(),true);
      }
 catch (      OperationFailedException e) {
        logger.error("can't create the new publish request",e);
        return false;
      }
      ClientTransaction transac=null;
      try {
        transac=this.parentProvider.getDefaultJainSipProvider().getNewClientTransaction(req);
      }
 catch (      TransactionUnavailableException e) {
        logger.error("can't create the client transaction",e);
        return false;
      }
      try {
        transac.sendRequest();
      }
 catch (      SipException e) {
        logger.error("can't send the PUBLISH request",e);
        return false;
      }
    }
 else     if (response.getStatusCode() == Response.CONDITIONAL_REQUEST_FAILED) {
      this.distantPAET=null;
      Request req=null;
      try {
        req=createPublish(this.subscriptionDuration,true);
      }
 catch (      OperationFailedException e) {
        logger.error("can't create the new publish request",e);
        return false;
      }
      ClientTransaction transac=null;
      try {
        transac=this.parentProvider.getDefaultJainSipProvider().getNewClientTransaction(req);
      }
 catch (      TransactionUnavailableException e) {
        logger.error("can't create the client transaction",e);
        return false;
      }
      try {
        transac.sendRequest();
      }
 catch (      SipException e) {
        logger.error("can't send the PUBLISH request",e);
        return false;
      }
    }
 else {
      logger.debug("error received from the network" + response);
      this.distantPAET=null;
      if (this.useDistantPA == false) {
        return true;
      }
      logger.debug("we enter into the peer to peer mode as the " + "distant PA mode fails");
      this.useDistantPA=false;
      if (this.republishTask != null) {
        this.republishTask.cancel();
        this.republishTask=null;
      }
    }
    processed=true;
  }
  return processed;
}
