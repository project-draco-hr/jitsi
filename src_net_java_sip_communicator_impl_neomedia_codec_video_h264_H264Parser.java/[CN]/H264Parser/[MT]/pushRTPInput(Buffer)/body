{
  long currentStamp=inputBuffer.getTimeStamp();
  boolean hasMarker=(inputBuffer.getFlags() & Buffer.FLAG_RTP_MARKER) != 0;
  if (!(currentStamp == lastTimestamp) || lastHasMarker) {
    reset();
  }
  lastTimestamp=currentStamp;
  byte[] inData=(byte[])inputBuffer.getData();
  int inputOffset=inputBuffer.getOffset();
  byte fByte=inData[inputOffset];
  int type=fByte & 0x1f;
  int nri=(fByte & 0x60) >> 5;
  if (nri == 0)   return false;
  try {
    if (type >= 1 && type <= 23) {
      System.arraycopy(startSequence,0,encodedFrame,encodedFrameLen,startSequence.length);
      encodedFrameLen+=startSequence.length;
      int len=inputBuffer.getLength();
      System.arraycopy(inData,inputOffset,encodedFrame,encodedFrameLen,len);
      encodedFrameLen+=len;
      ensureEncodedFramePaddingSize();
    }
 else     if (type == 28) {
      deencapsulateFU(fByte,inputBuffer);
    }
 else {
      logger.warn("Skipping unsupported NAL unit type");
      return false;
    }
  }
 catch (  Exception ex) {
    logger.warn("Cannot parse incoming " + ex.getMessage());
    reset();
    return false;
  }
  lastHasMarker=hasMarker;
  return hasMarker;
}
