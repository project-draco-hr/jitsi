{
  if (true)   return;
  fixture.provider1.addRegistrationStateChangeListener(regEvtCollector1);
  fixture.provider2.addRegistrationStateChangeListener(regEvtCollector2);
  fixture.provider1.register(new SecurityAuthorityImpl(System.getProperty(SipProtocolProviderServiceLick.ACCOUNT_1_PREFIX + ProtocolProviderFactory.PASSWORD).toCharArray()));
  fixture.provider2.register(new SecurityAuthorityImpl(System.getProperty(SipProtocolProviderServiceLick.ACCOUNT_2_PREFIX + ProtocolProviderFactory.PASSWORD).toCharArray()));
  try {
synchronized (registrationLock) {
      logger.debug("Waiting for registration to complete ...");
      registrationLock.wait(40000);
      logger.debug("Registration was completed or we lost patience.");
    }
  }
 catch (  InterruptedException ex) {
    logger.debug("Interrupted while waiting for registration",ex);
  }
catch (  Throwable t) {
    logger.debug("We got thrown out while waiting for registration",t);
  }
  Map supportedOperationSets=fixture.provider1.getSupportedOperationSets();
  Object lock=new Object();
synchronized (lock) {
    try {
      logger.debug("Giving the aim server time to notify for " + "our arrival!");
      lock.wait(5000);
    }
 catch (    Exception ex) {
    }
  }
  assertTrue("No events were dispatched during the registration process.",regEvtCollector1.collectedNewStates.size() > 0);
  assertTrue("No registration event notifying of registration was dispatched. " + "All events were: " + regEvtCollector1.collectedNewStates,regEvtCollector1.collectedNewStates.contains(RegistrationState.REGISTERED));
  fixture.provider1.removeRegistrationStateChangeListener(regEvtCollector1);
}
