{
  PushBufferStream inputStream=(PushBufferStream)inputStreamDesc.getInputStream();
  AudioFormat inputStreamFormat=(AudioFormat)inputStream.getFormat();
  Buffer buffer=new Buffer();
  if (sampleCount != 0) {
    Class<?> inputDataType=inputStreamFormat.getDataType();
    if (Format.byteArray.equals(inputDataType)) {
      buffer.setData(new byte[sampleCount * (inputStreamFormat.getSampleSizeInBits() / 8)]);
      buffer.setLength(0);
      buffer.setOffset(0);
    }
 else     throw new UnsupportedFormatException("!Format.getDataType().equals(byte[].class)",inputStreamFormat);
  }
  audioMixer.read(inputStream,buffer,inputStreamDesc.inputDataSourceDesc.inputDataSource);
  if (buffer.isDiscard())   return null;
  int inputLength=buffer.getLength();
  if (inputLength <= 0)   return null;
  AudioFormat inputFormat=(AudioFormat)buffer.getFormat();
  if (inputFormat == null)   inputFormat=inputStreamFormat;
  if (logger.isTraceEnabled() && (lastReadInputFormat != null) && !lastReadInputFormat.matches(inputFormat)) {
    lastReadInputFormat=inputFormat;
    logger.trace("Read inputSamples in different format " + lastReadInputFormat);
  }
  int inputFormatSigned=inputFormat.getSigned();
  if ((inputFormatSigned != AudioFormat.SIGNED) && (inputFormatSigned != Format.NOT_SPECIFIED))   throw new UnsupportedFormatException("AudioFormat.getSigned()",inputFormat);
  int inputChannels=inputFormat.getChannels();
  int outputChannels=outputFormat.getChannels();
  if ((inputChannels != outputChannels) && (inputChannels != Format.NOT_SPECIFIED) && (outputChannels != Format.NOT_SPECIFIED)) {
    logger.error("Read inputFormat with channels " + inputChannels + " while expected outputFormat channels is "+ outputChannels);
    throw new UnsupportedFormatException("AudioFormat.getChannels()",inputFormat);
  }
  double inputSampleRate=inputFormat.getSampleRate();
  double outputSampleRate=outputFormat.getSampleRate();
  if (inputSampleRate != outputSampleRate)   logger.warn("Read inputFormat with sampleRate " + inputSampleRate + " while expected outputFormat sampleRate is "+ outputSampleRate);
  Object inputData=buffer.getData();
  if (inputData instanceof byte[]) {
    int inputSampleSizeInBits=inputFormat.getSampleSizeInBits();
    byte[] inputSamples=(byte[])inputData;
    int[] outputSamples;
    int outputSampleSizeInBits=outputFormat.getSampleSizeInBits();
    if (logger.isTraceEnabled() && (inputSampleSizeInBits != outputSampleSizeInBits))     logger.trace("Read inputFormat with sampleSizeInBits " + inputSampleSizeInBits + ". Will convert to sampleSizeInBits"+ outputSampleSizeInBits);
switch (inputSampleSizeInBits) {
case 16:
      outputSamples=new int[inputSamples.length / 2];
    for (int i=0; i < outputSamples.length; i++) {
      int sample=ArrayIOUtils.readInt16(inputSamples,i * 2);
switch (outputSampleSizeInBits) {
case 16:
        break;
case 32:
      sample=Math.round(sample * INT_TO_SHORT_RATIO);
    break;
case 8:
case 24:
default :
  throw new UnsupportedFormatException("AudioFormat.getSampleSizeInBits()",outputFormat);
}
outputSamples[i]=sample;
}
buffer.setData(outputSamples);
buffer.setFormat(outputFormat);
buffer.setLength(outputSamples.length);
buffer.setOffset(0);
return buffer;
case 32:
outputSamples=new int[inputSamples.length / 4];
for (int i=0; i < outputSamples.length; i++) {
int sample=readInt(inputSamples,i * 4);
switch (outputSampleSizeInBits) {
case 16:
sample=Math.round(sample * SHORT_TO_INT_RATIO);
break;
case 32:
break;
case 8:
case 24:
default :
throw new UnsupportedFormatException("AudioFormat.getSampleSizeInBits()",outputFormat);
}
outputSamples[i]=sample;
}
buffer.setData(outputSamples);
buffer.setFormat(outputFormat);
buffer.setLength(outputSamples.length);
buffer.setOffset(0);
return buffer;
case 8:
case 24:
default :
throw new UnsupportedFormatException("AudioFormat.getSampleSizeInBits()",inputFormat);
}
}
 else if (inputData != null) {
throw new UnsupportedFormatException("Format.getDataType().equals(" + inputData.getClass() + ")",inputFormat);
}
return null;
}
