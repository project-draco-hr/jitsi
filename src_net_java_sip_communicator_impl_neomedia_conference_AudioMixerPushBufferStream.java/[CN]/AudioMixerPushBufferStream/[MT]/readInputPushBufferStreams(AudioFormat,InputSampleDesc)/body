{
  InputStreamDesc[] inputStreams=inputSampleDesc.inputStreams;
  Buffer buffer=inputSampleDesc.getBuffer(true);
  int maxInputSampleCount=0;
  int[][] inputSamples=inputSampleDesc.inputSamples;
  for (int i=0; i < inputStreams.length; i++) {
    InputStreamDesc inputStreamDesc=inputStreams[i];
    SourceStream inputStream=inputStreamDesc.getInputStream();
    if (inputStream instanceof PushBufferStream) {
      buffer.setDiscard(false);
      buffer.setLength(0);
      readInputPushBufferStream(inputStreamDesc,outputFormat,maxInputSampleCount,buffer);
      int sampleCount;
      int[] samples;
      if (buffer.isDiscard()) {
        sampleCount=0;
        samples=null;
      }
 else {
        sampleCount=buffer.getLength();
        if (sampleCount <= 0) {
          sampleCount=0;
          samples=null;
        }
 else {
          samples=(int[])buffer.getData();
        }
      }
      if (sampleCount == 0) {
        if ((TRACE_NON_CONTRIBUTING_READ_COUNT > 0) && logger.isTraceEnabled()) {
          inputStreamDesc.nonContributingReadCount++;
          if (inputStreamDesc.nonContributingReadCount >= TRACE_NON_CONTRIBUTING_READ_COUNT) {
            logger.trace("Failed to read actual inputSamples more than " + inputStreamDesc.nonContributingReadCount + " times from inputStream with hash code "+ inputStreamDesc.getInputStream().hashCode());
            inputStreamDesc.nonContributingReadCount=0;
          }
        }
      }
 else {
        buffer.setData(null);
        if (samples.length > sampleCount)         Arrays.fill(samples,sampleCount,samples.length,0);
        inputSamples[i]=samples;
        if (maxInputSampleCount < samples.length)         maxInputSampleCount=samples.length;
        if (inputSampleDesc.getTimeStamp() == Buffer.TIME_UNKNOWN)         inputSampleDesc.setTimeStamp(buffer.getTimeStamp());
        continue;
      }
    }
    inputSamples[i]=null;
  }
  return maxInputSampleCount;
}
