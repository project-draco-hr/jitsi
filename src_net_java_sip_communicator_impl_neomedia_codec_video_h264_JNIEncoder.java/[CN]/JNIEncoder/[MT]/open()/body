{
  if (opened)   return;
  if (inputFormat == null)   throw new ResourceUnavailableException("No input format selected");
  if (outputFormat == null)   throw new ResourceUnavailableException("No output format selected");
  VideoFormat outputVideoFormat=(VideoFormat)outputFormat;
  Dimension size=outputVideoFormat.getSize();
  int width=size.width;
  int height=size.height;
  long avcodec=FFmpeg.avcodec_find_encoder(FFmpeg.CODEC_ID_H264);
  avctx=FFmpeg.avcodec_alloc_context();
  FFmpeg.avcodeccontext_set_pix_fmt(avctx,FFmpeg.PIX_FMT_YUV420P);
  FFmpeg.avcodeccontext_set_size(avctx,width,height);
  FFmpeg.avcodeccontext_set_qcompress(avctx,0.6f);
  int bitRate=128000;
  int frameRate=(int)outputVideoFormat.getFrameRate();
  if (frameRate == Format.NOT_SPECIFIED)   frameRate=DEFAULT_FRAME_RATE;
  FFmpeg.avcodeccontext_set_bit_rate(avctx,bitRate);
  FFmpeg.avcodeccontext_set_bit_rate_tolerance(avctx,(bitRate / frameRate));
  FFmpeg.avcodeccontext_set_rc_max_rate(avctx,bitRate);
  FFmpeg.avcodeccontext_set_sample_aspect_ratio(avctx,0,0);
  FFmpeg.avcodeccontext_set_thread_count(avctx,1);
  FFmpeg.avcodeccontext_set_time_base(avctx,1,frameRate);
  FFmpeg.avcodeccontext_set_ticks_per_frame(avctx,2);
  FFmpeg.avcodeccontext_set_quantizer(avctx,30,31,4);
  FFmpeg.avcodeccontext_add_partitions(avctx,0x111);
  FFmpeg.avcodeccontext_set_mb_decision(avctx,FFmpeg.FF_MB_DECISION_SIMPLE);
  FFmpeg.avcodeccontext_set_rc_eq(avctx,"blurCplx^(1-qComp)");
  FFmpeg.avcodeccontext_add_flags(avctx,FFmpeg.CODEC_FLAG_LOOP_FILTER);
  FFmpeg.avcodeccontext_add_flags2(avctx,FFmpeg.CODEC_FLAG2_INTRA_REFRESH);
  FFmpeg.avcodeccontext_set_me_method(avctx,7);
  FFmpeg.avcodeccontext_set_me_subpel_quality(avctx,2);
  FFmpeg.avcodeccontext_set_me_range(avctx,16);
  FFmpeg.avcodeccontext_set_me_cmp(avctx,FFmpeg.FF_CMP_CHROMA);
  FFmpeg.avcodeccontext_set_scenechange_threshold(avctx,40);
  FFmpeg.avcodeccontext_set_crf(avctx,0);
  FFmpeg.avcodeccontext_set_rc_buffer_size(avctx,10);
  FFmpeg.avcodeccontext_set_gop_size(avctx,IFRAME_INTERVAL);
  FFmpeg.avcodeccontext_set_i_quant_factor(avctx,1f / 1.4f);
  FFmpeg.avcodeccontext_set_refs(avctx,1);
  FFmpeg.avcodeccontext_set_keyint_min(avctx,0);
  if (packetizationMode == 0) {
    FFmpeg.avcodeccontext_set_rtp_payload_size(avctx,Packetizer.MAX_PAYLOAD_SIZE);
  }
  ConfigurationService configuration=NeomediaActivator.getConfigurationService();
  String profile=(configuration == null) ? null : configuration.getString(DEFAULT_PROFILE_PNAME,DEFAULT_DEFAULT_PROFILE);
  try {
    FFmpeg.avcodeccontext_set_profile(avctx,BASELINE_PROFILE.equalsIgnoreCase(profile) ? FFmpeg.FF_PROFILE_H264_BASELINE : FFmpeg.FF_PROFILE_H264_MAIN);
  }
 catch (  UnsatisfiedLinkError ule) {
    logger.warn("The FFmpeg JNI library is out-of-date.");
  }
  if (FFmpeg.avcodec_open(avctx,avcodec) < 0) {
    throw new ResourceUnavailableException("Could not open codec. (size= " + width + "x"+ height+ ")");
  }
  encFrameLen=(width * height * 3) / 2;
  rawFrameBuffer=FFmpeg.av_malloc(encFrameLen);
  avframe=FFmpeg.avcodec_alloc_frame();
  int sizeInBytes=width * height;
  FFmpeg.avframe_set_data(avframe,rawFrameBuffer,sizeInBytes,sizeInBytes / 4);
  FFmpeg.avframe_set_linesize(avframe,width,width / 2,width / 2);
  encFrameBuffer=new byte[encFrameLen];
  if (keyFrameRequestee == null) {
    keyFrameRequestee=new KeyFrameControl.KeyFrameRequestee(){
      public boolean keyFrameRequest(){
        return JNIEncoder.this.keyFrameRequest();
      }
    }
;
  }
  if (keyFrameControl != null)   keyFrameControl.addKeyFrameRequestee(-1,keyFrameRequestee);
  opened=true;
  super.open();
}
