{
  long sequenceNumber=inBuffer.getSequenceNumber();
  int ret;
  if ((lastSequenceNumber != -1) && ((sequenceNumber - lastSequenceNumber) != 1)) {
    if (logger.isTraceEnabled())     logger.trace("Dropped RTP packets upto sequenceNumber " + lastSequenceNumber + " and continuing with sequenceNumber "+ sequenceNumber);
    if (usePLI && lastKeyframeRequestTimeStamp == -1) {
      sendRTCPFeedbackPLI();
    }
    ret=reset(outBuffer);
    if ((ret & OUTPUT_BUFFER_NOT_FILLED) == 0)     return ret;
  }
  long timeStamp=inBuffer.getTimeStamp();
  if (timeStamp != lastTimeStamp) {
    ret=reset(outBuffer);
    if ((ret & OUTPUT_BUFFER_NOT_FILLED) == 0)     return ret;
  }
  lastSequenceNumber=sequenceNumber;
  lastTimeStamp=timeStamp;
  byte[] in=(byte[])inBuffer.getData();
  int inOffset=inBuffer.getOffset();
  byte octet=in[inOffset];
  int nal_unit_type=octet & 0x1F;
  if ((nal_unit_type >= 1) && (nal_unit_type <= 23)) {
    fuaStartedAndNotEnded=false;
    ret=dePacketizeSingleNALUnitPacket(nal_unit_type,in,inOffset,inBuffer.getLength(),outBuffer);
  }
 else   if (nal_unit_type == 28) {
    ret=dePacketizeFUA(in,inOffset,inBuffer.getLength(),outBuffer);
    if (outBuffer.isDiscard())     fuaStartedAndNotEnded=false;
  }
 else {
    logger.warn("Dropping NAL unit of unsupported type " + nal_unit_type);
    fuaStartedAndNotEnded=false;
    outBuffer.setDiscard(true);
    ret=BUFFER_PROCESSED_OK;
  }
  outBuffer.setSequenceNumber(sequenceNumber);
  if ((inBuffer.getFlags() & Buffer.FLAG_RTP_MARKER) != 0)   outBuffer.setFlags(outBuffer.getFlags() | Buffer.FLAG_RTP_MARKER);
  if (usePLI && lastKeyframeRequestTimeStamp != -1 && System.currentTimeMillis() > (lastKeyframeRequestTimeStamp + PLI_INTERVAL)) {
    sendRTCPFeedbackPLI();
  }
  return ret;
}
