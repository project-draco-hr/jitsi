{
  int k, n, headrm;
  int rc_Q31, rc_mult1_Q30, rc_mult2_Q16;
  int[][] Atmp_QA=new int[2][Silk_SigProc_FIX.SKP_Silk_MAX_ORDER_LPC];
  int tmp_QA;
  int[] Aold_QA, Anew_QA;
  Anew_QA=Atmp_QA[order & 1];
  for (k=0; k < order; k++) {
    Anew_QA[k]=((int)A_Q13[k] << (QA - 13));
  }
  invGain_Q30[0]=(1 << 30);
  for (k=order - 1; k > 0; k--) {
    if ((Anew_QA[k] > A_LIMIT) || (Anew_QA[k] < -A_LIMIT)) {
      return 1;
    }
    rc_Q31=-(Anew_QA[k] << (31 - QA));
    rc_mult1_Q30=(Silk_typedef.SKP_int32_MAX >> 1) - Silk_SigProc_FIX.SKP_SMMUL(rc_Q31,rc_Q31);
    assert(rc_mult1_Q30 > (1 << 15));
    assert(rc_mult1_Q30 < (1 << 30));
    rc_mult2_Q16=Silk_Inlines.SKP_INVERSE32_varQ(rc_mult1_Q30,46);
    invGain_Q30[0]=(Silk_SigProc_FIX.SKP_SMMUL(invGain_Q30[0],rc_mult1_Q30) << 2);
    Silk_typedef.SKP_assert(invGain_Q30[0] >= 0);
    Silk_typedef.SKP_assert(invGain_Q30[0] <= 1 << 30);
    Aold_QA=Anew_QA;
    Anew_QA=Atmp_QA[k & 1];
    headrm=Silk_macros.SKP_Silk_CLZ32(rc_mult2_Q16) - 1;
    rc_mult2_Q16=(rc_mult2_Q16 << headrm);
    for (n=0; n < k; n++) {
      tmp_QA=Aold_QA[n] - (Silk_SigProc_FIX.SKP_SMMUL(Aold_QA[k - n - 1],rc_Q31) << 1);
      Anew_QA[n]=(Silk_SigProc_FIX.SKP_SMMUL(tmp_QA,rc_mult2_Q16) << (16 - headrm));
    }
  }
  if ((Anew_QA[0] > A_LIMIT) || (Anew_QA[0] < -A_LIMIT)) {
    return 1;
  }
  rc_Q31=-(Anew_QA[0] << (31 - QA));
  rc_mult1_Q30=(Silk_typedef.SKP_int32_MAX >> 1) - Silk_SigProc_FIX.SKP_SMMUL(rc_Q31,rc_Q31);
  invGain_Q30[0]=(Silk_SigProc_FIX.SKP_SMMUL(invGain_Q30[0],rc_mult1_Q30) << 2);
  Silk_typedef.SKP_assert(invGain_Q30[0] >= 0);
  Silk_typedef.SKP_assert(invGain_Q30[0] <= 1 << 30);
  return 0;
}
