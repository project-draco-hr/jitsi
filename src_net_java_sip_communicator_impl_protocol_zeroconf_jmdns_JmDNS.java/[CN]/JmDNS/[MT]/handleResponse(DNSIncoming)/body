{
  long now=System.currentTimeMillis();
  boolean hostConflictDetected=false;
  boolean serviceConflictDetected=false;
  logger.trace("JMDNS/handleResponse received " + msg.answers.size() + " messages");
  for (  DNSRecord rec : msg.answers) {
    logger.trace("PRINT: " + rec);
  }
  for (  DNSRecord rec : msg.answers) {
    boolean isInformative=false;
    boolean expired=rec.isExpired(now);
    logger.trace("JMDNS received : " + rec + " expired: "+ expired);
    DNSRecord c=(DNSRecord)cache.get(rec);
    if (c != null) {
      logger.trace("JMDNS has found " + rec + " in cache");
      if (expired) {
        isInformative=true;
        cache.remove(c);
      }
 else {
        logger.trace(new Boolean(c.isUnique()).toString() + c.getType() + c.getClazz()+ "/"+ DNSConstants.TYPE_TXT+ " "+ DNSConstants.CLASS_IN);
        if ((rec.isUnique() && ((rec.getType() & DNSConstants.TYPE_TXT) != 0) && ((rec.getClazz() & DNSConstants.CLASS_IN) != 0))) {
          logger.trace("UPDATING CACHE !! ");
          isInformative=true;
          cache.remove(c);
          cache.add(rec);
        }
 else {
          c.resetTTL(rec);
          rec=c;
        }
      }
    }
 else {
      if (!expired) {
        isInformative=true;
        logger.trace("Adding " + rec + " to the cache");
        cache.add(rec);
      }
    }
switch (rec.type) {
case DNSConstants.TYPE_PTR:
      if (rec.getName().indexOf("._mdns._udp.") >= 0) {
        if (!expired && rec.name.startsWith("_services._mdns._udp.")) {
          isInformative=true;
          registerServiceType(((DNSRecord.Pointer)rec).alias);
        }
        continue;
      }
    registerServiceType(rec.name);
  break;
}
if ((rec.getType() == DNSConstants.TYPE_A) || (rec.getType() == DNSConstants.TYPE_AAAA)) {
hostConflictDetected|=rec.handleResponse(this);
}
 else {
serviceConflictDetected|=rec.handleResponse(this);
}
if (isInformative) {
updateRecord(now,rec);
}
}
if (hostConflictDetected || serviceConflictDetected) {
new Prober().start();
}
}
