{
  try {
    byte buf[]=new byte[DNSConstants.MAX_MSG_ABSOLUTE];
    DatagramPacket packet=new DatagramPacket(buf,buf.length);
    while (state != DNSState.CANCELED) {
      packet.setLength(buf.length);
      socket.receive(packet);
      if (state == DNSState.CANCELED) {
        break;
      }
      try {
        if (localHost.shouldIgnorePacket(packet)) {
          continue;
        }
        DNSIncoming msg=new DNSIncoming(packet);
        if (logger.isTraceEnabled())         logger.trace("SocketListener.run() JmDNS in:" + msg.print(true));
synchronized (ioLock) {
          if (msg.isQuery()) {
            if (packet.getPort() != DNSConstants.MDNS_PORT) {
              handleQuery(msg,packet.getAddress(),packet.getPort());
            }
            handleQuery(msg,group,DNSConstants.MDNS_PORT);
          }
 else {
            handleResponse(msg);
          }
        }
      }
 catch (      IOException e) {
        logger.warn("run() exception ",e);
      }
    }
  }
 catch (  IOException e) {
    if (state != DNSState.CANCELED) {
      logger.warn("run() exception ",e);
      recover();
    }
  }
}
