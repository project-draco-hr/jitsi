{
synchronized (ioLock) {
    if (plannedAnswer == in) {
      plannedAnswer=null;
    }
    HashSet<DNSQuestion> questions=new HashSet<DNSQuestion>();
    HashSet<DNSRecord> answers=new HashSet<DNSRecord>();
    if (state == DNSState.ANNOUNCED) {
      try {
        boolean isUnicast=(port != DNSConstants.MDNS_PORT);
        for (Iterator<DNSEntry> iterator=in.questions.iterator(); iterator.hasNext(); ) {
          DNSEntry entry=iterator.next();
          if (entry instanceof DNSQuestion) {
            DNSQuestion q=(DNSQuestion)entry;
            if (isUnicast) {
              questions.add(q);
            }
            int type=q.type;
            if (type == DNSConstants.TYPE_ANY || type == DNSConstants.TYPE_SRV) {
              if (localHost.getName().equalsIgnoreCase(q.getName())) {
                DNSRecord answer=localHost.getDNS4AddressRecord();
                if (answer != null) {
                  answers.add(answer);
                }
                answer=localHost.getDNS6AddressRecord();
                if (answer != null) {
                  answers.add(answer);
                }
                type=DNSConstants.TYPE_IGNORE;
              }
 else {
                if (serviceTypes.containsKey(q.getName().toLowerCase())) {
                  type=DNSConstants.TYPE_PTR;
                }
              }
            }
switch (type) {
case DNSConstants.TYPE_A:
{
                DNSRecord answer=localHost.getDNS4AddressRecord();
                if (answer != null) {
                  answers.add(answer);
                }
                break;
              }
case DNSConstants.TYPE_AAAA:
{
              DNSRecord answer=localHost.getDNS6AddressRecord();
              if (answer != null) {
                answers.add(answer);
              }
              break;
            }
case DNSConstants.TYPE_PTR:
{
            for (Iterator<ServiceInfo> serviceIterator=services.values().iterator(); serviceIterator.hasNext(); ) {
              ServiceInfo info=serviceIterator.next();
              if (info.getState() == DNSState.ANNOUNCED) {
                if (q.name.equalsIgnoreCase(info.type)) {
                  DNSRecord answer=localHost.getDNS4AddressRecord();
                  if (answer != null) {
                    answers.add(answer);
                  }
                  answer=localHost.getDNS6AddressRecord();
                  if (answer != null) {
                    answers.add(answer);
                  }
                  answers.add(new DNSRecord.Pointer(info.type,DNSConstants.TYPE_PTR,DNSConstants.CLASS_IN,DNSConstants.DNS_TTL,info.getQualifiedName()));
                  answers.add(new DNSRecord.Service(info.getQualifiedName(),DNSConstants.TYPE_SRV,DNSConstants.CLASS_IN | DNSConstants.CLASS_UNIQUE,DNSConstants.DNS_TTL,info.priority,info.weight,info.port,localHost.getName()));
                  answers.add(new DNSRecord.Text(info.getQualifiedName(),DNSConstants.TYPE_TXT,DNSConstants.CLASS_IN | DNSConstants.CLASS_UNIQUE,DNSConstants.DNS_TTL,info.text));
                }
              }
            }
            if (q.name.equalsIgnoreCase("_services._mdns._udp.local.")) {
              for (Iterator<String> serviceTypeIterator=serviceTypes.values().iterator(); serviceTypeIterator.hasNext(); ) {
                answers.add(new DNSRecord.Pointer("_services._mdns._udp.local.",DNSConstants.TYPE_PTR,DNSConstants.CLASS_IN,DNSConstants.DNS_TTL,serviceTypeIterator.next()));
              }
            }
            break;
          }
case DNSConstants.TYPE_SRV:
case DNSConstants.TYPE_ANY:
case DNSConstants.TYPE_TXT:
{
          ServiceInfo info=services.get(q.name.toLowerCase());
          if (info != null && info.getState() == DNSState.ANNOUNCED) {
            DNSRecord answer=localHost.getDNS4AddressRecord();
            if (answer != null) {
              answers.add(answer);
            }
            answer=localHost.getDNS6AddressRecord();
            if (answer != null) {
              answers.add(answer);
            }
            answers.add(new DNSRecord.Pointer(info.type,DNSConstants.TYPE_PTR,DNSConstants.CLASS_IN,DNSConstants.DNS_TTL,info.getQualifiedName()));
            answers.add(new DNSRecord.Service(info.getQualifiedName(),DNSConstants.TYPE_SRV,DNSConstants.CLASS_IN | DNSConstants.CLASS_UNIQUE,DNSConstants.DNS_TTL,info.priority,info.weight,info.port,localHost.getName()));
            answers.add(new DNSRecord.Text(info.getQualifiedName(),DNSConstants.TYPE_TXT,DNSConstants.CLASS_IN | DNSConstants.CLASS_UNIQUE,DNSConstants.DNS_TTL,info.text));
          }
          break;
        }
default :
{
        break;
      }
  }
}
}
for (DNSRecord knownAnswer : in.answers) {
if (knownAnswer.ttl > DNSConstants.DNS_TTL / 2 && answers.remove(knownAnswer)) {
  if (logger.isDebugEnabled())   logger.debug("JmDNS Responder Known Answer Removed");
}
}
if (answers.size() != 0) {
if (logger.isDebugEnabled()) logger.debug("run() JmDNS responding");
DNSOutgoing out=null;
if (isUnicast) {
  out=new DNSOutgoing(DNSConstants.FLAGS_QR_RESPONSE | DNSConstants.FLAGS_AA,false);
}
for (Iterator<DNSQuestion> i=questions.iterator(); i.hasNext(); ) {
  out.addQuestion(i.next());
}
for (Iterator<DNSRecord> i=answers.iterator(); i.hasNext(); ) {
  out=addAnswer(in,addr,port,out,i.next());
}
send(out);
}
this.cancel();
}
 catch (Throwable e) {
logger.warn("run() exception ",e);
close();
}
}
}
}
